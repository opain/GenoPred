<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Rethinking the reference standardisation process</title>

<script src="site_libs/header-attrs-2.26/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />
<link rel="shortcut icon" href="Images/logo/favicon.ico">

<link rel="stylesheet" href="styles/night-mode.css" id="nightModeStylesheet">

<script>
function toggleNightMode() {
    var stylesheet = document.getElementById('nightModeStylesheet');
    if (stylesheet.disabled) {
        stylesheet.disabled = false;
    } else {
        stylesheet.disabled = true;
    }
}
</script>

<label class="switch">
  <input type="checkbox" id="toggleNightMode" checked>
  <span class="slider round"></span>
</label>

<script>
document.getElementById('toggleNightMode').addEventListener('change', function() {
    var stylesheet = document.getElementById('nightModeStylesheet');
    if (this.checked) {
        stylesheet.disabled = false;
    } else {
        stylesheet.disabled = true;
    }
});
</script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YR18ZB3PR3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YR18ZB3PR3');
</script>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="styles/styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><img class="logo-img" src="Images/logo/Horizontal_white.png" style="height: 42px;" /></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Pipeline
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="pipeline_overview.html">Overview</a>
    </li>
    <li>
      <a href="pipeline_readme.html">Instructions</a>
    </li>
    <li>
      <a href="pipeline_technical.html">Technical documentation</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Research
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="research_index.html">Overview</a>
    </li>
    <li>
      <a href="comparison_of_methods_summary.html">Polygenic Scoring Methods Comparison</a>
    </li>
    <li>
      <a href="Functionally_informed_prediction.html">Quantifying Polygenic Signal Mediated by Altered Gene Expression</a>
    </li>
    <li>
      <a href="Absolute_Conversion.html">Translating Polygenic Scores onto the Absolute Scale</a>
    </li>
  </ul>
</li>
<li>
  <a href="more_index.html">More</a>
</li>
<li>
  <a href="https://github.com/opain/GenoPred">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Rethinking the reference standardisation
process</h1>

</div>


<hr />
<div id="background" class="section level1">
<h1>Background</h1>
<p>In some scenarios, PGS produced by GenoPred are shifted on the
reference-standardised distribution. This has motivated a rethink of the
reference standardisation process in GenoPred.</p>
<p>The shift appears to be caused by missing data, though I do not
understand why, since we are using reference frequency imputation during
scoring. I have explored whether a shift in ancestry relative to the
reference population could also cause a shift in the PGS, but projected
PC correction of the PGS does not resolve the issue. Missingness seems
to be a part of the issue, so we will need to simulate some data to
explore causes and solutions further.</p>
<p>Though, it makes me wonder whether our current approach for reference
standardisation is suboptimal. We originally thought that reference
frequency imputation is good as it allows simple PGS calculation, and
missingness will lead to gravitation to the mean, but perhaps a more
individual specific solution is available. Here is a summary of thoughts
on this:</p>
<ul>
<li><p>Impact of Imputing Missing Variants Using Reference MAF: When
missing variants in the target sample are imputed using reference
population allele frequencies, the resulting PGS tends to gravitate
toward the reference mean. This approach also narrows the score’s
distribution, reducing its variance and thus diminishing the variance
explained (R²) within the target sample.</p></li>
<li><p>Interpretable Score Generation in GenoPred: GenoPred aims to
create interpretable polygenic scores that are robust and transferrable
across samples. A key element is the use of reference-based
standardization, allowing score calculations to be independent of target
sample variations and supporting consistent interpretations across
studies and populations.</p></li>
<li><p>Adjustment for Missing Data in Interpretation: To account for
missing variants in the target, scaling and standardizing the PGS as
done by tools like Impute.me can improve interpretability. This approach
provides z-scores that adjust for missing data, yielding a more accurate
standardization. However, individual-level R² values will vary among
participants due to differences in missing SNPs and their
contributions.</p></li>
<li><p>Estimating Individual-Level R² Using GWAS Summary Statistics:
With well-calibrated SNP weights, it is feasible to estimate
individual-level R² by leveraging GWAS summary statistics and accounting
for missing variants. This enables a calculation of R² per individual
that reflects their specific missing data profile, although these
estimates are influenced by the covariates used in the GWAS.</p></li>
<li><p>Adjusting Reported R² for Missing Data Impact: Alternatively, a
global R² adjustment can be applied by using a correction factor that
reflects the variance lost due to missing variants. This could involve
calculating the ratio of summary statistic-based R² with missing data to
R² assuming no missing data, providing a more accurate interpretation of
the score’s predictive power for each individual.</p></li>
</ul>
</div>
<div id="action-point" class="section level1">
<h1>Action point</h1>
<p>Create example target data with degrees of missingness that can used
to see impact of missingness in the output of GenoPred. Try to recreate
shift in PGS for anorexia nervosa, as it seems to be highly correlated
with PC1, which seems to highlight the issue. If there are no bugs
causing the shift, we may need to consider alternative, target sample
specific solutions discuss above.</p>
</div>
<div id="simulation" class="section level1">
<h1>Simulation</h1>
<pre class="r"><code># Load necessary libraries
library(ggplot2)

# Set up parameters for simulation
set.seed(1)
num_individuals &lt;- 1000
num_snps &lt;- 1000
impute &lt;- F

# 1. Generate SNP effects and reference allele frequencies
snp_effects &lt;- data.frame(
  SNP = paste0(&quot;rs&quot;, 1:num_snps),
  effect_size = rnorm(num_snps, mean = 0.1, sd = 0.02)
)

# Reference population allele frequencies
ref_allele_freq &lt;- data.frame(
  SNP = paste0(&quot;rs&quot;, 1:num_snps),
  ref_freq = runif(num_snps, 0.1, 0.9)
)

# 2. Generate Target Genotypes based on Reference Allele Frequencies
# Each individual&#39;s genotype is sampled from a binomial distribution with probability equal to ref_freq
# This will give genotypes with frequencies matching the reference population
target_genotypes &lt;- data.frame(ID = 1:num_individuals)
for (snp in snp_effects$SNP) {
  ref_freq &lt;- ref_allele_freq$ref_freq[ref_allele_freq$SNP == snp]
  target_genotypes[[snp]] &lt;- rbinom(num_individuals, 2, ref_freq)  # Generates 0, 1, or 2 with matching frequency
}

# Introduce some missing data randomly (optional, if you want missingness to remain)
# Let&#39;s assume a 10% missing rate
for (snp in snp_effects$SNP) {
  missing_indices &lt;- sample(1:num_individuals, size = round(0.9 * num_individuals))
  target_genotypes[missing_indices, snp] &lt;- NA
}

if(impute){
  # Impute Missing Genotypes Using Reference Allele Frequency
  for (snp in snp_effects$SNP) {
    ref_freq &lt;- ref_allele_freq$ref_freq[ref_allele_freq$SNP == snp]
    target_genotypes[[snp]][is.na(target_genotypes[[snp]])] &lt;- round(2 * ref_freq)
  }
}

# 2. Calculate Population-Score Mean for each SNP
snp_effects$population_score &lt;- 2 * ref_allele_freq$ref_freq * snp_effects$effect_size
population_mean_pgs &lt;- sum(snp_effects$population_score)

# 3. Calculate Raw PGS for each individual
# Ensure genotypes are a matrix (num_individuals x num_snps)
# Rows are individuals, columns are SNPs
genotype_matrix &lt;- as.matrix(target_genotypes[, snp_effects$SNP])
genotype_matrix[is.na(genotype_matrix)] &lt;- 0

# Multiply the genotype matrix by the effect vector
raw_pgs_vector &lt;- genotype_matrix %*% snp_effects$effect_size

pgs_data &lt;- data.frame(ID = target_genotypes$ID, Raw_PGS = genotype_matrix %*% snp_effects$effect_size)

# 4. Adjust Population Standardization Based on Missing Variants
# Calculate individual-specific mean and standard deviation based on observed variants only
# Convert target genotypes to a matrix, excluding the first column (ID column)
genotype_matrix &lt;- as.matrix(target_genotypes[, -1])

# Create a mask to identify observed SNPs (1 for observed, 0 for NA)
observed_mask &lt;- !is.na(genotype_matrix)

# Replace NAs with 0 for easier calculation
genotype_matrix[is.na(genotype_matrix)] &lt;- 0

# Calculate population mean for each SNP (this is a constant for each SNP across individuals)
population_means &lt;- snp_effects$population_score

# Calculate population standard deviation per SNP based on allele frequencies and effect sizes
snp_variances &lt;- 2 * ref_allele_freq$ref_freq * (1 - ref_allele_freq$ref_freq) * (snp_effects$effect_size^2)
snp_std_devs &lt;- sqrt(snp_variances)

# Calculate observed population mean and standard deviation for each individual
# Expand population_means to match observed_mask dimensions
population_means_matrix &lt;- matrix(population_means, nrow = nrow(observed_mask), ncol = ncol(observed_mask), byrow = TRUE)
# Expand snp_variances to match observed_mask dimensions
snp_variances_matrix &lt;- matrix(snp_variances, nrow = nrow(observed_mask), ncol = ncol(observed_mask), byrow = TRUE)

observed_means &lt;- rowSums(observed_mask * population_means_matrix)
observed_sds &lt;- sqrt(rowSums(observed_mask * snp_variances_matrix))

# Calculate Zero-Centered Score and Z-score in a vectorized way
pgs_data$ZeroCenteredScore &lt;- pgs_data$Raw_PGS - observed_means
pgs_data$Z_score &lt;- pgs_data$ZeroCenteredScore / observed_sds

# 5. Estimate Overall R^2 based on GWAS Summary Statistics
# Sum variance explained by each SNP based on allele frequencies and effect sizes
total_r2 &lt;- sum(2 * ref_allele_freq$ref_freq * (1 - ref_allele_freq$ref_freq) * 
                (snp_effects$effect_size^2))

# Precompute the constant part of the R² formula for each SNP
snp_r2_contrib &lt;- 2 * ref_allele_freq$ref_freq * (1 - ref_allele_freq$ref_freq) * (snp_effects$effect_size^2)

# Convert target genotypes to a matrix, skipping the first column (ID column)
genotype_matrix &lt;- as.matrix(target_genotypes[, -1])

# Create a mask matrix to identify observed SNPs (1 for observed, 0 for NA)
observed_mask &lt;- !is.na(genotype_matrix)

# Replace NA values in the genotype matrix with 0 for calculations
genotype_matrix[is.na(genotype_matrix)] &lt;- 0

# Calculate R² for each individual by summing observed SNP contributions
pgs_data$Individual_R2 &lt;- rowSums(observed_mask * snp_r2_contrib)

# Plotting

# 1. Plot Raw PGS Distribution
ggplot(pgs_data, aes(x = Raw_PGS)) +
  geom_histogram(fill = &quot;skyblue&quot;, color = &quot;black&quot;) +
  labs(title = &quot;Distribution of Raw Polygenic Scores&quot;,
       x = &quot;Raw PGS&quot;,
       y = &quot;Count&quot;) +
  theme_minimal()

# 2. Plot Zscore Distribution
ggplot(pgs_data, aes(x = Z_score)) +
  geom_histogram(fill = &quot;skyblue&quot;, color = &quot;black&quot;) +
  labs(title = &quot;Distribution of Polygenic Z Scores&quot;,
       x = &quot;PGS Z_score&quot;,
       y = &quot;Count&quot;) +
  theme_minimal()

# 3. Plot Individual-Level R^2 Distribution
ggplot(pgs_data, aes(x = Individual_R2)) +
  geom_histogram(fill = &quot;skyblue&quot;, color = &quot;black&quot;) +
  labs(x = &quot;Proportion of PGS R2&quot;,
       y = &quot;Count&quot;) +
  theme_minimal()</code></pre>
<pre class="r"><code># Function to simulate genotypes, polygenic scores, and perform optional imputation and standardization
simulate_genotypes_pgs &lt;- function(num_individuals = 500, num_snps = 500, impute = FALSE, missing_rate = 0.1, seed = 1) {
  # Set up parameters for simulation
  set.seed(seed)
  
  # 1. Generate SNP effects and reference allele frequencies
  snp_effects &lt;- data.frame(
    SNP = paste0(&quot;rs&quot;, 1:num_snps),
    effect_size = rnorm(num_snps, mean = 0.1, sd = 0.02)
  )
  
  # Reference population allele frequencies
  ref_allele_freq &lt;- data.frame(
    SNP = paste0(&quot;rs&quot;, 1:num_snps),
    ref_freq = runif(num_snps, 0.1, 0.9)
  )
  
  # 2. Generate Target Genotypes based on Reference Allele Frequencies
  target_genotypes &lt;- data.frame(ID = 1:num_individuals)
  for (snp in snp_effects$SNP) {
    ref_freq &lt;- ref_allele_freq$ref_freq[ref_allele_freq$SNP == snp]
    target_genotypes[[snp]] &lt;- rbinom(num_individuals, 2, ref_freq)
  }
  
  # Introduce missing data randomly
  for (snp in snp_effects$SNP) {
    missing_indices &lt;- sample(1:num_individuals, size = round(missing_rate * num_individuals))
    target_genotypes[missing_indices, snp] &lt;- NA
  }
  
  # Impute missing genotypes if specified
  if (impute) {
    for (snp in snp_effects$SNP) {
      ref_freq &lt;- ref_allele_freq$ref_freq[ref_allele_freq$SNP == snp]
      target_genotypes[[snp]][is.na(target_genotypes[[snp]])] &lt;- 2 * ref_freq
    }
  }
  
  # 3. Calculate Population-Score Mean for each SNP
  snp_effects$population_score &lt;- 2 * ref_allele_freq$ref_freq * snp_effects$effect_size
  population_mean_pgs &lt;- sum(snp_effects$population_score)
  
  # 4. Calculate Raw PGS for each individual
  genotype_matrix &lt;- as.matrix(target_genotypes[, snp_effects$SNP])
  observed_mask &lt;- !is.na(genotype_matrix)
  genotype_matrix[is.na(genotype_matrix)] &lt;- 0
  raw_pgs_vector &lt;- genotype_matrix %*% snp_effects$effect_size
  pgs_data &lt;- data.frame(ID = target_genotypes$ID, Raw_PGS = raw_pgs_vector)
  
  # 5. Adjust Population Standardization Based on Missing Variants
  # Expand population_means and snp_variances as matrices to match observed_mask dimensions
  population_means &lt;- snp_effects$population_score
  snp_variances &lt;- 2 * ref_allele_freq$ref_freq * (1 - ref_allele_freq$ref_freq) * (snp_effects$effect_size^2)
  
  population_means_matrix &lt;- matrix(population_means, nrow = nrow(observed_mask), ncol = ncol(observed_mask), byrow = TRUE)
  snp_variances_matrix &lt;- matrix(snp_variances, nrow = nrow(observed_mask), ncol = ncol(observed_mask), byrow = TRUE)
  
  # Calculate observed means and standard deviations without unintended recycling
  observed_means &lt;- rowSums(observed_mask * population_means_matrix)
  observed_sds &lt;- sqrt(rowSums(observed_mask * snp_variances_matrix))
  
  # Calculate Zero-Centered Score and Z-score
  pgs_data$ZeroCenteredScore &lt;- pgs_data$Raw_PGS - observed_means
  pgs_data$Z_score &lt;- pgs_data$ZeroCenteredScore / observed_sds
  
  # 6. Estimate Overall R^2
  total_r2 &lt;- sum(snp_variances)
  
  # Calculate individual R² values
  pgs_data$Individual_R2 &lt;- rowSums(observed_mask * snp_variances_matrix)
  
  # Return the results
  list(
    snp_effects = snp_effects,
    ref_allele_freq = ref_allele_freq,
    target_genotypes = target_genotypes,
    pgs_data = pgs_data,
    total_r2 = total_r2
  )
}

pgs_z_all &lt;- NULL
r2_all &lt;- NULL
for(n_snp in c(100, 500)){
  for(missingness in c(0, 0.1, 0.2, 0.3, 0.4, 0.8)){
    for(imp in c(T, F)){
      tmp &lt;- simulate_genotypes_pgs(
        impute = imp,
        num_individuals = 1000,
        num_snps = n_snp,
        missing_rate = missingness
      )
      tmp2 &lt;- tmp$pgs_data
      tmp2$impute&lt;-imp
      tmp2$missing_rate&lt;-missingness
      tmp2$num_snps&lt;-n_snp
      tmp2$total_r2&lt;-tmp$total_r2
      pgs_z_all &lt;- rbind(pgs_z_all, tmp2)
    }
  }
}

library(ggplot2)
library(cowplot)

pgs_z_all$missing_rate_lab &lt;- paste0(&#39;Missing = &#39;, pgs_z_all$missing_rate)
pgs_z_all$num_snps_lab &lt;- paste0(&#39;N SNP = &#39;, pgs_z_all$num_snps)

pgs_z_all$missing_rate_lab &lt;- factor(pgs_z_all$missing_rate_lab, levels = unique(pgs_z_all$missing_rate_lab))
pgs_z_all$num_snps_lab &lt;- factor(pgs_z_all$num_snps_lab, levels = unique(pgs_z_all$num_snps_lab))

###
# Show the mean and SD on the plot
###

# N SNP doesn&#39;t change anything, so just plot missing rate with NSNP 500
pgs_z_all_nsnp500 &lt;- pgs_z_all[pgs_z_all$num_snps == 500,]

# Calculate mean and SD without dplyr
mean_z &lt;- tapply(pgs_z_all_nsnp500$Z_score, 
                 list(pgs_z_all_nsnp500$impute, pgs_z_all_nsnp500$missing_rate_lab), 
                 mean, na.rm = TRUE)
sd_z &lt;- tapply(pgs_z_all_nsnp500$Z_score, 
               list(pgs_z_all_nsnp500$impute, pgs_z_all_nsnp500$missing_rate_lab), 
               sd, na.rm = TRUE)

# Convert the results to a data frame for ggplot
mean_z_df &lt;- as.data.frame(as.table(mean_z))
sd_z_df &lt;- as.data.frame(as.table(sd_z))
mean_r2_df &lt;- as.data.frame(as.table(mean_z))
colnames(mean_z_df) &lt;- c(&quot;impute&quot;, &quot;missing_rate_lab&quot;, &quot;mean_z&quot;)
colnames(sd_z_df) &lt;- c(&quot;impute&quot;, &quot;missing_rate_lab&quot;, &quot;sd_z&quot;)
stats &lt;- merge(mean_z_df, sd_z_df, by = c(&quot;impute&quot;, &quot;missing_rate_lab&quot;))

# Plot with density and annotated mean/SD values
ggplot(pgs_z_all_nsnp500, aes(x = Z_score, fill = impute)) +
  geom_vline(xintercept = 0) +
  geom_density(alpha = 0.5, position = &quot;identity&quot;) +
  labs(x = &quot;PGS Z_score&quot;, y = &quot;Density&quot;, fill = &#39;Impute&#39;, colour = &#39;Impute&#39;) +
  facet_grid(. ~ missing_rate_lab) +
  theme_half_open() +
  panel_border() +
  geom_text(
    data = stats,
    aes(
      x = ifelse(impute == &quot;TRUE&quot;, -Inf, Inf),  # Place one group on left, other on right
      y = Inf, 
      label = paste0(&quot;Mean: &quot;, round(mean_z, 2), &quot;\nSD: &quot;, round(sd_z, 2)),
      color = impute
    ),
    hjust = ifelse(stats$impute == &quot;TRUE&quot;, -0.1, 1.1),  # Adjust horizontal justification
    vjust = 1.5, size = 3, inherit.aes = FALSE, show.legend = FALSE
  )

# Plot quantiles to see normality
ggplot(pgs_z_all_nsnp500, aes(sample = Z_score, color = impute)) +
  geom_qq() +
  geom_qq_line() +
  geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;, color = &quot;black&quot;) +  # Add y = x line
  labs(x = &quot;Theoretical Quantiles&quot;, y = &quot;Observed Quantiles&quot;, color = &#39;Impute&#39;) +
  facet_grid(. ~ missing_rate_lab) +
  theme_half_open() +
  panel_border()</code></pre>
</div>

<!-- footer.html -->
<hr/>

<div class="centered-container">
<div class="rounded-image-container" style="width: 500px;">
<img src="Images/logo/sponsors.png">
</div>
</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
