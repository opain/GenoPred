---
title: "Mind the Gap: Quantifying and Recovering Polygenic Score Signal Lost to Variant Missingness"
output: 
  html_document:
    theme: cosmo
    toc: true
    toc_float: true
    toc_depth: 2
    css: styles/styles.css
    includes:
      in_header: header.html
      after_body: footer.html

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
library(knitr)
```

***

# Overview

## Introduction

Polygenic scores (PGS) are increasingly used to stratify individuals by genetic risk for complex traits. However, their predictive performance depends not only on how well the score was trained, but also on how well the target dataset matches the score’s SNP content — in terms of variant availability, imputation quality, and linkage disequilibrium (LD) structure.

In practice, many variants in published score files are either missing or poorly imputed in real-world target datasets. This variant mismatch leads to reduced PGS performance, yet it is rarely quantified or addressed systematically. In this project, we evaluate how SNP availability and imputation quality affect polygenic score accuracy, and we implement LD-based methods to redistribute signal from missing variants to those that are available.

We benchmark theoretical and empirical approaches for estimating the relative performance of variant-restricted or imputation-filtered PGS, and show that LD-aware redistribution can recover a substantial portion of lost predictive power — without requiring phenotype data.

## Analysis Overview

### 1. Setup and Resources
- Define SNP sets: HapMap3, SBayesRC.
- Load score files from the PGS Catalog and GenoPred.
- Load or generate genotype data for OpenSNP, UK Biobank (target), and 1KG+HGDP (reference).
- Download imputation R² values from RSQ Browser and match to score files.

### 2. Variant Availability and Imputation Quality
- Quantify variant overlap between PGS and target genotypes.
- Visualise distributions of imputation R².
- Summarise missingness and mean imputation quality by method and dataset.

### 3. Theoretical R² Loss Estimation
- Estimate expected score variance using:
  - Marginal: \( \beta^2 \cdot 2f(1-f) \cdot R^2 \)
  - LD-aware: \( \beta^\top R \beta \)
- Compare retained R² across SNP sets and imputation thresholds.

### 4. LD-based Signal Redistribution
- Use LD projection to reassign weights from missing/low-R² SNPs to observed SNPs.
- Scale redistributed weights by imputation quality.
- Compare adjusted vs. original weights and resulting scores.

### 5. Empirical Validation of Relative Score Accuracy
- Compute scores in OpenSNP, UKB, and 1KG+HGDP:
  - Full vs. restricted vs. LD-adjusted scores.
- Estimate relative R² by score-score correlation:
  - \( R^2 = \text{cor}(PGS_{adjusted}, PGS_{full})^2 \)
- If phenotypes available (OpenSNP/UKB), compute score–trait correlation (optional).

### 6. Summary and Visualisation
- Plot relative R² loss and recovery across methods and datasets.
- Summarise tradeoffs between variant density, imputation quality, and performance.
- Highlight scenarios where LD-based adjustment is most beneficial.

### 7. Optional: Integration with GenoPred
- Use GenoPred pipeline to generate new scores using different SNP sets.
- Benchmark portability and performance using standardised outputs.

***

# Download and harmonise SNP lists

We need to combine the various lists of SNPs in some way. They are different dbSNP builds or genome builds. Lets harmonise them using the full dbSNP 151 dataset for non-ambiguous autosomal SNPs.

***

## HapMap3 

<details><summary>Show code</summary>

```{r}

setwd('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/')
library(data.table)
source('../functions/misc.R')
source_all('../functions')

# Read in the SNP data from the default GenoPred reference (1KG+HGDP HapMap3)
hm3 <- read_pvar('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/ref/ref.chr')
nrow(hm3) # 1204449

# Store snplist
dir.create('~/oliverpainfel/Analyses/mind_the_gap/snp_data', recursive = T)
saveRDS(hm3, '~/oliverpainfel/Analyses/mind_the_gap/snp_data/hm3.rds')

```

</details>

***

## SBayesRC

<details><summary>Show code</summary>

```{bash}
# Download SBayesRC EUR LD reference with 7 million variants
cd ~/oliverpainfel/Data/SBayesRC/
gdown 1mKQ3uU_XD6zlNefxEWMl1M42I0gTyOs3 # ukbEUR_Imputed.tar.xz

# Extract snp.info file
tar -xvf ukbEUR_Imputed.tar.xz ukbEUR_Imputed/snp.info

# Download height PGS from SBayesRC paper
wget https://gctbhub.cloud.edu.au/data/SBayesRC/share/v1.0/PGS/HT.txt.gz

```

```{r}
library(data.table)
library(GenoUtils)

# Read in SBayesRC snp.info file
sbayesrc_snpinfo <- fread('~/oliverpainfel/Data/SBayesRC/ukbEUR_Imputed/snp.info') # Build GRCh37

# Delete information we don't need
sbayesrc_snpinfo <- sbayesrc_snpinfo[, c('Chrom', 'PhysPos', 'ID', 'A1', 'A2'), with=F]
names(sbayesrc_snpinfo) <- c('CHR','BP','SNP','A1','A2')

# Remove ambiguous variants
sbayesrc_snpinfo$IUPAC <- snp_iupac(sbayesrc_snpinfo$A1, sbayesrc_snpinfo$A2)
sbayesrc_snpinfo <- sbayesrc_snpinfo[sbayesrc_snpinfo$IUPAC != 'S' & sbayesrc_snpinfo$IUPAC != 'W',]
nrow(sbayesrc_snpinfo) # 6253944

# Insert RSIDs by merging with dbSNP reference based on CHR BP A1 A2 information (they are both GRCh37)
sbayesrc_snpinfo_harm <- NULL
for(i in 1:22){
  print(i)
  # Read in dbSNP data
  ref_i <- readRDS(paste0('~/oliverpainfel/Data/dbSNP/00-All.snps.nonambiguous.chr',i,'.rds'))
  
  # Insert IUPAC codes
  ref_i$IUPAC <- snp_iupac(ref_i$A1, ref_i$A2)

  # Rename columns prior to merging with target
  names(ref_i)<-paste0('REF.',names(ref_i))
  ref_i$BP<-ref_i[[paste0('REF.BP_GRCh37')]]
  ref_i<-ref_i[, c('REF.CHR','REF.SNP','BP','REF.A1','REF.A2','REF.IUPAC'), with=F]

  # Subset sbayesrc_snpinfo to chr == i
  target_i <- sbayesrc_snpinfo[sbayesrc_snpinfo$CHR == i,]
  
  # Merge by BP
  ref_target<-merge(target_i, ref_i, by = 'BP')
  
  # Identify targ-ref strand flips, and flip target
  flip_logical<-detect_strand_flip(targ = ref_target$IUPAC, ref = ref_target$REF.IUPAC)

  flipped<-ref_target[flip_logical,]
  flipped$A1<-snp_allele_comp(flipped$A1)
  flipped$A2<-snp_allele_comp(flipped$A2)
  flipped$IUPAC<-snp_iupac(flipped$A1, flipped$A2)
  
  # Identify SNPs that have matched IUPAC
  matched<-ref_target[ref_target$IUPAC == ref_target$REF.IUPAC,]
  matched<-rbind(matched, flipped)
  
  # Set REF.SNP to SNP column
  matched$SNP <- NULL
  names(matched)[names(matched) == 'REF.SNP']<-'SNP'

  sbayesrc_snpinfo_harm <- rbind(sbayesrc_snpinfo_harm, matched)
}

# Check number of variant in SBayesRC remaining after reference harmonisation
nrow(sbayesrc_snpinfo_harm) # 6254034 of 6253944

# Update column names
sbayesrc_snpinfo_harm <- sbayesrc_snpinfo_harm[, c('CHR', 'BP', 'SNP', 'A1', 'A2'), with = F]

# Store snplist for sbayesrc '7M' reference.
dir.create('~/oliverpainfel/Analyses/mind_the_gap/snp_data', recursive = T)
saveRDS(sbayesrc_snpinfo_harm, '~/oliverpainfel/Analyses/mind_the_gap/snp_data/sbayesrc_7m.rds')

```

</details>

Interestingly, there are ~1M ambiguous variants in the SBayesRC reference. This limits the generalisability of the score files as hard to know which strand we are looking at. 

***

## RsqBrowser2

<details><summary>Show code</summary>

```{bash}
# Download imputation data across arrays and populations from Rsq Browser
cd ~/oliverpainfel/Data/RsqBrowser2
wget https://rsq-browser.i-med.ac.at/downloads/1/mlof.bi.snv.tab.gz
```

```{r}
library(data.table)
library(GenoUtils)

# Read in RsqBrowser data (Build GRCh38)
rsq <- fread('~/oliverpainfel/Data/RsqBrowser2/mlof.bi.snv.tab.gz')

# Remove columns we don't want
rsq <- rsq[,!grepl('_in$', names(rsq)), with=F]

# Update column names
names(rsq)[1:5] <- c('CHR', 'BP', 'A2', 'A1','FREQ')

# Remove 'chr' string from CHR
rsq$CHR <- as.numeric(gsub('chr', '', rsq$CHR))
  
# Remove ambiguous variants
rsq$IUPAC <- snp_iupac(rsq$A1, rsq$A2)
rsq <- rsq[rsq$IUPAC != 'S' & rsq$IUPAC != 'W',]
nrow(rsq) # 48306483

# Insert RSIDs by merging with dbSNP reference based on CHR BP A1 A2 information (they are both GRCh37)
rsq_harm <- NULL
for(i in 1:22){
  print(i)
  # Read in dbSNP data
  ref_i <- readRDS(paste0('~/oliverpainfel/Data/dbSNP/00-All.snps.nonambiguous.chr',i,'.rds'))
  
  # Insert IUPAC codes
  ref_i$IUPAC <- snp_iupac(ref_i$A1, ref_i$A2)

  # Rename columns prior to merging with target
  names(ref_i)<-paste0('REF.',names(ref_i))
  ref_i$BP<-ref_i[[paste0('REF.BP_GRCh38')]]
  ref_i<-ref_i[, c('REF.CHR','REF.SNP','BP','REF.BP_GRCh37','REF.A1','REF.A2','REF.IUPAC'), with=F]

  # Subset rsq to chr == i
  target_i <- rsq[rsq$CHR == i,]
  
  # Merge by BP
  ref_target<-merge(target_i, ref_i, by = 'BP')
  
  # Identify targ-ref strand flips, and flip target
  flip_logical<-detect_strand_flip(targ = ref_target$IUPAC, ref = ref_target$REF.IUPAC)

  flipped<-ref_target[flip_logical,]
  flipped$A1<-snp_allele_comp(flipped$A1)
  flipped$A2<-snp_allele_comp(flipped$A2)
  flipped$IUPAC<-snp_iupac(flipped$A1, flipped$A2)
  
  # Identify SNPs that have matched IUPAC
  matched<-ref_target[ref_target$IUPAC == ref_target$REF.IUPAC,]
  matched<-rbind(matched, flipped)

  # Set BP to GRCh37
  matched$BP <- NULL
  names(matched)[names(matched) == 'REF.BP_GRCh37']<-'BP'

  # Set REF.SNP to SNP column
  names(matched)[names(matched) == 'REF.SNP']<-'SNP'

  rsq_harm <- rbind(rsq_harm, matched)
}

# Check number of variant in SBayesRC remaining after reference harmonisation
nrow(rsq_harm) # 43991073 of 48306483

rsq_harm <- rsq_harm[, !(names(rsq_harm) %in% c('REF.CHR', 'REF.A1', 'REF.A2', 'REF.IUPAC', 'IUPAC')), with = F]

rsq_harm <- rsq_harm[, c('CHR','BP','SNP','A1','A2', names(rsq_harm)[!(names(rsq_harm) %in% c('CHR','BP','SNP','A1','A2'))]), with=F] 
  
# Store snplist for rsq reference.
saveRDS(rsq_harm, '~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')

# Reduce size of rsq by restricting to variants present in either hm3 or sbayesr
hm3 <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/hm3.rds')
sbayesrc <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/sbayesrc_7m.rds')
both <- rbind(hm3, sbayesrc)
both <- both[!duplicated(both),]

rsq_harm_subset <- rsq_harm[rsq_harm$SNP %in% both$SNP,]
rsq_harm_subset <- rsq_harm_subset[paste0(rsq_harm_subset$SNP, ':', rsq_harm_subset$A1, ':', rsq_harm_subset$A2) %in% paste0(both$SNP, ':', both$A1, ':', both$A2),]

saveRDS(rsq_harm_subset, '~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.hm3_sbayesrc.rds')
```

</details>

***

# Download and harmonise PGSC score files

Download all score files for CAD from PGSC as an example. Harmonise with the reference using GenoPred.

```{bash}
# Make a temp directory containing GenoPred reference plink files, but dense .rds files, so we can use the external_score_processor script to harmonise.

mkdir ~/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp
for chr in $(seq 1 22);do
  for file in $(echo pvar pgen psam);do
  ln -s /users/k1806347/oliverpainfel/Data/hgdp_1kg/genopred_dense/ref/ref.chr${chr}.${file} /users/k1806347/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp/ref.chr${chr}.${file}
  done
  ln -s /users/k1806347/oliverpainfel/Data/dbSNP/00-All.snps.nonambiguous.chr${chr}.rds /users/k1806347/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp/ref.chr${chr}.rds
done
ln -s /users/k1806347/oliverpainfel/Data/hgdp_1kg/genopred_dense/ref/ref.pop.txt /users/k1806347/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp/ref.pop.txt
ln -s /users/k1806347/oliverpainfel/Data/hgdp_1kg/genopred_dense/ref/keep_files /users/k1806347/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp/keep_files
ln -s /users/k1806347/oliverpainfel/Data/hgdp_1kg/genopred_dense/ref/freq_files /users/k1806347/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp/freq_files

```

```{r}
######
# score_list
######
# Donwload a csv listing all PGS for CAD
library(data.table)
pgsc_cad <- fread('~/oliverpainfel/Analyses/mind_the_gap/pgsc/pgs_scores_data_cad.csv')

score_ids<-gsub(' .*','', pgsc_cad$`Polygenic Score ID & Name`)
score_list<- data.table(
  name = score_ids,
  path = NA,
  label = score_ids)

dir.create('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config', recursive = T)

write.table(score_list, '~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt', col.names = T, row.names = F, quote = F)

######
# config
######

config<-c(
  "outdir: /users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output",
  "refdir: /users/k1806347/oliverpainfel/Analyses/mind_the_gap/dense_ref_tmp",
  "config_file: /users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/config_cad.yaml",
  "score_list: /users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt",
  "min_overlap_external: 0"
)

write.table(config, '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/config_cad.yaml', col.names = F, row.names = F, quote = F)

```

```{bash}
snakemake \
  --profile slurm \
  --use-conda \
  --configfile=/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/config_cad.yaml \
  prep_pgs_external -n
```

***

# Variant Availability and Imputation Quality

## Across SNP-lists

Check the number and imputation quality of HapMap3 and SBayesRC variants available across across arrays and imputation panels.

<details><summary>Show code</summary>

```{r}
library(data.table)

# Read in snplist and rsq information
hm3 <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/hm3.rds')
sbayesrc <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/sbayesrc_7m.rds')
rsq<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.hm3_sbayesrc.rds')

# We will merge by SNP, A1 and A2 information, so delete other information
hm3$CHR <- NULL
hm3$BP <- NULL
sbayesrc$CHR <- NULL
sbayesrc$BP <- NULL
rsq$CHR <- NULL
rsq$BP <- NULL

# Merge with hm3 and sbayesrc snplists
hm3_rsq <- merge(hm3, rsq, by = c('SNP','A1','A2'), all.x = T)
hm3_rsq <-melt(hm3_rsq, id.vars = c('SNP','A1','A2','FREQ'))
hm3_rsq$snplist <- 'hm3'
sbayesrc_rsq <- merge(sbayesrc, rsq, by = c('SNP','A1','A2'), all.x = T)
sbayesrc_rsq <-melt(sbayesrc_rsq, id.vars = c('SNP','A1','A2','FREQ'))
sbayesrc_rsq$snplist <- 'sbayesrc'
both_rsq <- rbind(hm3_rsq, sbayesrc_rsq)

both_rsq$array <- gsub('_.*','', both_rsq$variable)
both_rsq$panel <- gsub('.*_','', both_rsq$variable)

# Recode panels
both_rsq$panel <- factor(
  both_rsq$panel,
  levels = c("1kg", "hrc", "top"),
  labels = c("1000 Genomes", "HRC", "TOPMed")
)

# Recode arrays
both_rsq$array <- factor(
  both_rsq$array,
  levels = c("HC", "OE", "MG", "IO"),
  labels = c("Core", "OmniExpress", "MEGA", "Omni 2.5M")
)

# assuming both_rsq is already a data.table
summary_tab <- both_rsq[, .(
  n            = .N,
  prop_non_na  = mean(!is.na(value)),
  prop_gt_0.5  = mean(value > 0.5,  na.rm = TRUE),
  prop_gt_0.9  = mean(value > 0.9,  na.rm = TRUE),
  prop_gt_0.95 = mean(value > 0.95, na.rm = TRUE),
  prop_gt_0.99 = mean(value > 0.99, na.rm = TRUE),
  mean_rsq     = mean(value,  na.rm = TRUE),
  median_rsq   = median(value, na.rm = TRUE)
), by = .(snplist, array, panel)]

library(ggplot2)
library(cowplot)

prop_long <- melt(
  summary_tab,
  id.vars = c("snplist","array","panel"),
  measure.vars = c("prop_non_na","prop_gt_0.5","prop_gt_0.9","prop_gt_0.95","prop_gt_0.99"),
  variable.name = "metric", value.name = "prop"
)

prop_long$metric <- factor(
  prop_long$metric,
  levels = c(
    'prop_non_na',
    'prop_gt_0.5',
    'prop_gt_0.9',
    'prop_gt_0.95',
    'prop_gt_0.99'
  ),
  labels = c('Missing', 'RSQ > 0.5', 'RSQ > 0.9', 'RSQ > 0.95', 'RSQ > 0.99')
)

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_metrics.png',
    units = 'px',
    width = 2500,
    height = 2500,
    res = 300)

ggplot(prop_long, aes(x = array, y = prop, fill = snplist)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  facet_grid(metric ~ panel) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Genotyping array", y = "Proportion", fill = "SNP list",
       title = "Proportion metrics by SNP list, array, and reference panel") +
  theme_half_open() +
  panel_border() +
  background_grid() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
dev.off()

# Make a boxplot
boxplot<- ggplot(both_rsq, aes(x = snplist, y = value, fill = snplist)) +
  geom_boxplot(outliers = FALSE) +
  labs(
    x = "SNP list",
    y = expression(Imputation~r^2),
    title = "Distribution of imputation r² across SNP list, array, and panel"
  ) +
  theme_classic() +
  theme_half_open() +
  background_grid() +
  panel_border() +
  facet_grid(array ~ panel, scales = "free_y") +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_boxplot.png',
    units = 'px',
    width = 3000,
    height = 3000,
    res = 300)

  boxplot

dev.off()

# Make a boxplot with outliers
boxplot<- ggplot(both_rsq, aes(x = snplist, y = value, fill = snplist)) +
  geom_boxplot() +
  labs(
    x = "SNP list",
    y = expression(Imputation~r^2),
    title = "Distribution of imputation r² across SNP list, array, and panel"
  ) +
  theme_classic() +
  theme_half_open() +
  background_grid() +
  panel_border() +
  facet_grid(array ~ panel, scales = "free_y") +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_boxplot_with_outliers.png',
    units = 'px',
    width = 3000,
    height = 3000,
    res = 300)

  boxplot

dev.off()

```

</details>

<details><summary>Show results</summary>

<div class="centered-container">
<div class="rounded-image-container" style="width: 60%;">
![](~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_metrics.png)
</div>
</div>

<div class="centered-container">
<div class="rounded-image-container" style="width: 60%;">
![](~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_boxplot.png)
</div>
</div>

</details>

There is slightly worse imputation quality for the SBayesRC variants, but actually the Rsq is very high for both when using a typical array and TopMed imputation.

***

## PGSC score files

```{r}
# Read in the log files from the harmonisation log to check the number of variants originally and after harmonisation
library(tidyr)
library(dplyr)
score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

nsnps<-NULL
for(i in score_list$name){
  log <-
    readLines(
      paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        i,
        '/ref-',
        i,
        '.log'
      )
    )
  
  original <- log[grepl('Original score file contains', log)]
  original <- gsub('Original score file contains ', '', original)
  original <- gsub(' variants.', '', original)

  unmapped <- log[grepl('after removing variants that were not mapped ', log)]
  unmapped <- gsub('Score file contains ', '', unmapped)
  unmapped <- gsub(' variants after removing variants that were not mapped.*', '', unmapped)

  a2 <- log[grepl(' variants after removing multi-allelic', log)]
  a2 <- gsub('Score file contains ', '', a2)
  a2 <- gsub(' variants after removing multi-allelic.*', '', a2)

  non_auto <- log[grepl(' variants after removing those with chromosome not in:', log)]
  non_auto <- gsub('Score file contains ', '', non_auto)
  non_auto <- gsub(' variants after removing those with chromosome not in:.*', '', non_auto)
  
  nodup <- log[grepl('variants after removing duplicates.', log)]
  nodup <- gsub('Score file contains ', '', nodup)
  nodup <- gsub(' variants after removing duplicates.', '', nodup)

  n_ambig <- log[grepl('ambiguous variants\\.', log)]
  n_ambig <- gsub('Score file contains ', '', n_ambig)
  n_ambig <- gsub(' ambiguous variants.', '', n_ambig)
  nonambig_snp <- as.character(as.numeric(nodup) - as.numeric(n_ambig))
    
  n_flip <- log[grepl('non-ambiguous variants were flipped', log)]
  n_flip <- gsub(' non-ambiguous variants were flipped.*', '', n_flip)
  if(any(grepl('No variants were flipped', log))) n_flip <- '0'
  
  inref <- log[grepl('After matching variants to the reference', log)]
  inref <- gsub('After matching variants to the reference, ', '', inref)
  inref <- gsub(' variants remain.', '', inref)

  nsnps<-rbind(nsnps,
             data.table(
               ID = i,
               original = original,
               unmapped = unmapped,
               a2 = a2,
               non_auto = non_auto,
               nodup = nodup,
               n_ambig = n_ambig,
               nonambig_snp = nonambig_snp,
               n_flip = n_flip,
               inref = inref
             ))
}

nsnps$original <- as.numeric(nsnps$original)
nsnps$unmapped <- as.numeric(nsnps$unmapped)
nsnps$a2 <- as.numeric(nsnps$a2)
nsnps$non_auto <- as.numeric(nsnps$non_auto)
nsnps$nodup <- as.numeric(nsnps$nodup)
nsnps$n_ambig <- as.numeric(nsnps$n_ambig)
nsnps$nonambig_snp <- as.numeric(nsnps$nonambig_snp)
nsnps$n_flip <- as.numeric(nsnps$n_flip)
nsnps$inref <- as.numeric(nsnps$inref)

# Very few variants are being removed due to being autosomal, but this is a limitation of GenoPred, so discount the effect of this filter.
nsnps$original <- nsnps$original - (nsnps$a2 - nsnps$non_auto)
nsnps$unmapped <- nsnps$unmapped - (nsnps$a2 - nsnps$non_auto)
nsnps$a2 <- nsnps$a2 - (nsnps$a2 - nsnps$non_auto)
  
# Calculate loss at each stage
step_loss <- nsnps %>%
  transmute(
    ID,
    `Unmapped`       = (original - unmapped) / original,
    `Unknown A2`       = (unmapped - a2) / original,
    `Duplicated`       = (non_auto - nodup) / original,
    `Strand\nAmbiguous`   = (nodup - nonambig_snp) / nodup,
    `Not in dbSNP`   = (nonambig_snp - inref) / nonambig_snp,
    `All criteria`   = (original - inref) / original,
    `All criteria\n(excl. ambiguous)`   = (original - (inref + n_ambig)) / original
  ) %>%
  pivot_longer(-ID, names_to = "step", values_to = "lost_prop")

# There are no variants lost due to being duplicates
step_loss <- step_loss[step_loss$step != 'Duplicated',]

# Count number of PGS loosing >2% of variants
sum(step_loss$lost_prop[step_loss$step == "All criteria"] > 0.05) # 41
sum(step_loss$lost_prop[step_loss$step == "All criteria\n(excl. ambiguous)"] > 0.05) # 22
length(unique(step_loss$ID)) # 78

step_loss$step <- factor(step_loss$step, levels = unique(step_loss$step))

# Make plots
png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_violin.png',
    units = 'px', width = 2500, height = 1500, res = 300)
ggplot(step_loss, aes(step, lost_prop)) +
  geom_violin(fill = "steelblue", alpha = 0.6, trim = FALSE, bw = 0.005) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, NA)) +
  labs(x = NULL, y = "Proportion of variants lost") +
  theme_half_open() +
  background_grid()
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_hist_excl_ambig.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  step_loss[step_loss$step == "All criteria\n(excl. ambiguous)", ], 
  aes(x = lost_prop)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_histogram(width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'Proportion of variants lost', y = 'Number of PGS') +
  theme_half_open() +
  background_grid()
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_hist_all.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  step_loss[step_loss$step == "All criteria", ], 
  aes(x = lost_prop)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_histogram(width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'Proportion of variants lost', y = 'Number of PGS') +
  theme_half_open() +
  background_grid()
dev.off()

sum_bar <- step_loss %>%
  group_by(step) %>%
  summarise(mean_loss = mean(lost_prop, na.rm = TRUE), .groups = "drop")
sum_bar$step <- as.character(sum_bar$step)
sum_bar$step[sum_bar$step == "Strand\nAmbiguous"] <- "Strand Ambiguous"
sum_bar$step<-factor(sum_bar$step, levels = unique(sum_bar$step), labels = sum_bar$step)

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_stacked.png',
    units = 'px', width = 1500, height = 1500, res = 300)
ggplot(sum_bar[sum_bar$step != "All criteria\n(excl. ambiguous)" & sum_bar$step != "All criteria",], aes(x = "All PGS", y = mean_loss, fill = step)) +
  geom_bar(stat = "identity", width = 0.6, colour = 'black') +
  scale_y_continuous() +
  scale_fill_brewer(palette = "Blues", direction = 1) +
  labs(x = NULL, y = "Proportion of variants lost (mean)", fill = "Filter") +
  theme_half_open() +
  background_grid()
dev.off()

# The vast majority of non-ambiguous variants are present in the reference. Some variants are not in the dbSNP file I downloaded, and they will not be in the 1KG+HGDP reference either.

# 15 of the 78 score files required non-ambiguous variants to be flipped to the positive strand. In some cases just 1 of 6M variants had to be flipped. The maximum proportion of non-ambiguous variants that had to be flipped was 5%, but usually it is a tiny percentage. I suppose this means it is fairly safe to assume the ambiguous variants will also be on the positive strand more often than not.

nsnps$prop_flip <- nsnps$n_flip/nsnps$nonambig_snp

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_hist_strandambig.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  nsnps, 
  aes(x = prop_flip)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_histogram(bins = 60, width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'Proportion of non-ambiguous on reverse strand', y = 'Number of PGS') +
  theme_half_open() +
  background_grid()
dev.off()

# It is hard to understand why the strand flips would have occured. Some of the score files with flips are from PRS-CS which should align everything to the PRS-CS reference, which is presumably on the forward strand. To make GenoPred fully flexible, it should probably allow for strand ambiguous variants, and just report the proportion of strand flips among non-ambiguous variants. Then user can use ambiguous variants if they are sure their data is on the forward strand, and set keep ambiguous in the config, like pgsc_calc. This will make the reference data much larger than it is now. This will allow for the SBayesRC 7M variant reference, and PGSC score files better.

# Make a histogram showing distribution of original nsnp
png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_hist_original.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  nsnps, 
  aes(x = original)) +
  geom_histogram(bins = 60, width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'N SNP', y = 'Number of PGS') +
  theme_half_open() +
  background_grid()
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/pgsc_filtering_hist_original_low.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  nsnps[nsnps$original < 20000,], 
  aes(x = original)) +
  geom_histogram(bins = 60, width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'N SNP', y = 'Number of PGS') +
  theme_half_open() +
  background_grid()
dev.off()

```

```{r}
library(data.table)

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

# Read in rsq information
rsq<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')

# We will merge by SNP, A1 and A2 information, so delete other information
rsq$CHR <- NULL
rsq$BP <- NULL
rsq$IUPAC <- snp_iupac(rsq$A1, rsq$A2)
rsq$A1 <- NULL
rsq$A2 <- NULL

summary_tab <- NULL
for(i in score_list$name){
  
  # Read in score file
  score_i <- fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        i,
        '/ref-',
        i,
        '.harmonised.gz'
      ))
  
  # We will merge by SNP, A1 and A2 information, so delete other information
  score_i$CHR <- NULL
  score_i$BP <- NULL
  #score_i$effect_weight <- NULL
  
  # Merge rsq with score file
  score_i$IUPAC <- snp_iupac(score_i$A1, score_i$A2)
  score_i$A1 <- NULL
  score_i$A2 <- NULL
  score_i_rsq <- merge(score_i, rsq, by = c('SNP','IUPAC'), all.x = T)
  score_i_rsq$IUPAC <- NULL
  score_i_rsq <-melt(score_i_rsq, id.vars = c('SNP'))
  score_i_rsq$ID <- i
  
  score_i_rsq$array <- gsub('_.*','', score_i_rsq$variable)
  score_i_rsq$panel <- gsub('.*_','', score_i_rsq$variable)

  summary_tab_i <- score_i_rsq[, .(
    n            = .N,
    prop_non_na  = mean(!is.na(value)),
    prop_gt_0.5  = mean(value > 0.5,  na.rm = TRUE),
    prop_gt_0.9  = mean(value > 0.9,  na.rm = TRUE),
    prop_gt_0.95 = mean(value > 0.95, na.rm = TRUE),
    prop_gt_0.99 = mean(value > 0.99, na.rm = TRUE),
    mean_rsq     = mean(value,  na.rm = TRUE),
    median_rsq   = median(value, na.rm = TRUE)
  ), by = .(ID, array, panel)]

  summary_tab <- rbind(summary_tab, summary_tab_i)
}

# Recode panels
summary_tab$panel <- factor(
  summary_tab$panel,
  levels = c("1kg", "hrc", "top"),
  labels = c("1000 Genomes", "HRC", "TOPMed")
)

# Recode arrays
summary_tab$array <- factor(
  summary_tab$array,
  levels = c("HC", "OE", "MG", "IO"),
  labels = c("Core", "OmniExpress", "MEGA", "Omni 2.5M")
)

library(ggplot2)
library(cowplot)

prop_long <- melt(
  summary_tab,
  id.vars = c("ID","array","panel"),
  measure.vars = c("prop_non_na","prop_gt_0.5","prop_gt_0.9","prop_gt_0.95","prop_gt_0.99"),
  variable.name = "metric", value.name = "prop"
)

prop_long$metric <- factor(
  prop_long$metric,
  levels = c(
    'prop_non_na',
    'prop_gt_0.5',
    'prop_gt_0.9',
    'prop_gt_0.95',
    'prop_gt_0.99'
  ),
  labels = c('Non-missing', 'RSQ > 0.5', 'RSQ > 0.9', 'RSQ > 0.95', 'RSQ > 0.99')
)

saveRDS(prop_long, '~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_metrics_pgs.rds')
prop_long<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_metrics_pgs.rds')

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_metrics_pgs.png',
    units = 'px',
    width = 2500,
    height = 2500,
    res = 300)

ggplot(prop_long[prop_long$ID %in% unique(prop_long$ID)[1:5],], aes(x = array, y = prop, fill = ID)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  facet_grid(metric ~ panel) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Genotyping array", y = "Proportion", fill = "SNP list",
       title = "Proportion metrics by SNP list, array, and reference panel") +
  theme_half_open() +
  panel_border() +
  background_grid() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) 
dev.off()


ggplot(prop_long, aes(x = array, y = prop, fill = panel)) +
  geom_boxplot(width = 0.15) +
  facet_wrap(~ metric, ncol = 1, scales = "free_y") +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Array", y = "Proportion", title = "Distribution by metric, array, and panel") +
  theme_minimal(base_size = 12)

```

***

# Estimate PGS performance drop

Here we will estimate the relative decrease in PGS R2 due to removal of ambiguous variants, and poor imputation of non-ambiguous variants. We will use the PGSC CAD score files as an example, estimating the impact of missing variants based on the effect size and allele frequency of the variants. This will only be done for the non-ambiguous variants, and then extrapolated to ambiguous variants (since they will follow the same distribution of effect size and allele frequency).

```{r}
library(data.table)
library(dplyr)
library(purrr)
library(tidyr)

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

# Read in rsq information
rsq<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')

# We will merge by SNP, A1 and A2 information, so delete other information
rsq$CHR <- NULL
rsq$BP <- NULL
rsq$IUPAC <- snp_iupac(rsq$A1, rsq$A2)
rsq$A1 <- NULL
rsq$A2 <- NULL

# Insert genotype variance
rsq$vg <- 2 * rsq$FREQ * (1 - rsq$FREQ)

# Make function for estimating relative PGS R2
rel_pgs_r2 <- function(beta, vg, rsq){
  # Calculate variance of PGS without missingness
  denom <- sum(beta^2 * vg)

  # Calculate variance of PGS allowing for imputation rsq
  num <- sum(beta^2 * vg * rsq) 
  
  # Calculate relative R2
  return(num / denom)
}

# --- Relative R^2 retained when masking a subset of variants (uses vg only) ---
.rel_r2_with_mask_vg <- function(dat, vg_col = "vg", mask_idx = integer(0)) {
  stopifnot(vg_col %in% names(dat))
  vg_all <- dat[[vg_col]]
  denom  <- sum(vg_all, na.rm = TRUE)
  if (!is.finite(denom) || denom <= 0) return(NA_real_)
  if (length(mask_idx)) vg_keep <- vg_all[-mask_idx] else vg_keep <- vg_all
  num <- sum(vg_keep, na.rm = TRUE)
  num / denom
}

# --- 1) Learn missingness -> relative-R^2 curve (non-ambiguous variants only) ---
pgs_r2_vs_missingness_vg <- function(dat_nonambig,
                                     vg_col = "vg",
                                     m_grid = seq(0, 0.6, by = 0.05),
                                     n_sims = 50,
                                     seed = 1) {
  stopifnot(vg_col %in% names(dat_nonambig))
  dat_nonambig <- dat_nonambig %>% filter(is.finite(.data[[vg_col]]))
  stopifnot(nrow(dat_nonambig) > 10)
  set.seed(seed)

  sims <- map_dfr(m_grid, function(m) {
    S <- nrow(dat_nonambig)
    k <- floor(m * S)
    rels <- replicate(n_sims, {
      idx <- if (k > 0) sample.int(S, size = k, replace = FALSE) else integer(0)
      .rel_r2_with_mask_vg(dat_nonambig, vg_col, idx)
    })
    tibble(missing_prop = m,
           rel_mean = mean(rels, na.rm = TRUE),
           rel_median = median(rels, na.rm = TRUE),
           rel_sd = sd(rels, na.rm = TRUE),
           rel_q05 = quantile(rels, 0.05, na.rm = TRUE),
           rel_q95 = quantile(rels, 0.95, na.rm = TRUE))
  })

  # Often close to linear: loss ≈ slope * missing_prop
  fit <- lm(I(1 - rel_mean) ~ 0 + missing_prop, data = sims)
  list(curve = sims, slope = unname(coef(fit)[1]), model = fit)
}

pgs_r2 <- NULL
for(i in score_list$name){
  
  # Read in score file
  score_i <- fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        i,
        '/ref-',
        i,
        '.harmonised.gz'
      ))
  
  # We will merge by SNP, A1 and A2 information, so delete other information
  score_i$CHR <- NULL
  score_i$BP <- NULL
  #score_i$effect_weight <- NULL
  
  # Merge rsq with score file
  score_i$IUPAC <- snp_iupac(score_i$A1, score_i$A2)
  score_i$A1 <- NULL
  score_i$A2 <- NULL
  score_i_rsq <- merge(score_i, rsq, by = c('SNP','IUPAC'), all.x = T)
  
  # Set rsq of missing variants as 0
  score_i_rsq[is.na(score_i_rsq)]<-0
  
  # Calculate relative PRS R2 across arrays and panels
  for(j in c("HC_1kg", "HC_hrc", "HC_top", "OE_1kg", "OE_hrc", "OE_top", "IO_1kg", "IO_hrc", "IO_top", "MG_1kg", "MG_hrc", "MG_top")){
    pgs_r2<-rbind(pgs_r2, data.table(
      ID = i,
      group = j,
      rel_r2 = rel_pgs_r2(beta=score_i_rsq$effect_weight, vg=score_i_rsq$vg, rsq = score_i_rsq[[j]])
    ))
  }
}

# For the last score files looked estimate relationship between missingness and PGS R2
curve_fit <- pgs_r2_vs_missingness_vg(
  dat_nonambig = score_i_rsq,
  vg_col = "vg",
  m_grid = seq(0, 0.6, by = 0.05),
  n_sims = 20
)

plot(curve_fit$curve$missing_prop, curve_fit$curve$rel_mean)
# This shows the relationship is linear when missingness is random.

pgs_r2$array <- gsub('_.*','', pgs_r2$group)
pgs_r2$panel <- gsub('.*_','', pgs_r2$group)

# Recode panels
pgs_r2$panel <- factor(
  pgs_r2$panel,
  levels = c("1kg", "hrc", "top"),
  labels = c("1000 Genomes", "HRC", "TOPMed")
)

# Recode arrays
pgs_r2$array <- factor(
  pgs_r2$array,
  levels = c("HC", "OE", "MG", "IO"),
  labels = c("Core", "OmniExpress", "MEGA", "Omni 2.5M")
)

library(ggplot2)
library(cowplot)

saveRDS(pgs_r2, '~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs.rds')
pgs_r2<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs.rds')

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs.png',
    units = 'px',
    width = 2500,
    height = 1500,
    res = 300)

ggplot(pgs_r2[pgs_r2$ID %in% unique(pgs_r2$ID)[1:5],], aes(x = array, y = rel_r2, fill = ID)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  facet_grid(. ~ panel) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Genotyping array", y = "Proportion", fill = "SNP list",
       title = "Relative PGS performance by platform and array") +
  theme_half_open() +
  panel_border() +
  background_grid() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) 
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics.png',
    units = 'px',
    width = 2500,
    height = 1500,
    res = 300)

ggplot(pgs_r2, aes(x = array, y = rel_r2, fill = panel)) +
  geom_boxplot(width = 0.15) +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Array", y = "Proportion", title = "Distribution by metric, array, and panel") +
  theme_minimal(base_size = 12)
dev.off()

```

After talking with Naomi I have realised that this variance only (diagonal-only / 2pq) approach for estimating the relative decrease in PGS does not take into account covariance between SNPs, which will make the relative PGS R2 estimate less accurate. We can use the SBayesRC eigen decomposed LD matrices to account for the covariance properly.

Another point that was made by Naomi, is that for an individual it is more about the genotype probabilities than the sample-level info. Often genotype probabilities are not available, and often we only have hard calls, so imputation quality is not available either. This PGS uncertainty due to imputation certainty can only be computed for some genotype data formats. If it is just hard calls then the relative PGS R2 can only account for missing variants, and assume variants that are present are well imputed. Calculating INFO will only be possible for samples with >100 individuals. 

Steps forward, make GenoPred better for using external score files by including a denser reference, then include a relative PGS R2 estimator (using INFO if available - bgen,plink2,vcf and N > 100), and PGS R2 recovery method.

Make a reference only including common variants, but include the ambiguous variants to be more inclusive and assume everything on positive strand unless evidence of otherwise.

Question for Naomi, the QS metric should be specific to a given target ancestry?

***

# Estimate PGS performance drop accountng for LD

Same as before but this time allowing for LD when estimating relative R2.

```{r}

setwd('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/')
library(data.table)
library(ggplot2)
library(cowplot)
library(GenoUtils)
library(foreach)
library(doMC)
registerDoMC(80)

source('../functions/misc.R')
source_all('../functions')

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

# Read in rsq information
rsq<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')

# We will merge by SNP, A1 and A2 information, so delete other information
rsq$CHR <- NULL
rsq$BP <- NULL

# Restrict to variants in the dense SBayesRC reference
sbayesrc_info<-fread('~/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/sbayesrc_ref_dense/EUR/snp.info')
rsq_subset <- rsq[rsq$SNP %in% sbayesrc_info$ID,]

jobs <-
  CJ(
    id = score_list$name,
    test = c(
      "HC_1kg",
      "HC_hrc",
      "HC_top",
      "OE_1kg",
      "OE_hrc",
      "OE_top",
      "IO_1kg",
      "IO_hrc",
      "IO_top",
      "MG_1kg",
      "MG_hrc",
      "MG_top"
    ),
    unique = TRUE
  )

foreach(i = 1:nrow(jobs), .combine = c, .options.multicore = list(preschedule = FALSE)) %dopar% {
  if(file.exists(
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.', 
      jobs$test[i],
      '.rsq.txt'
    ))){
    return(NULL)
  }
  
  print(paste0(jobs$id[i],':', jobs$test[i]))
  
  # Read in score file
  score_i <- fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        jobs$id[i],
        '/ref-',
        jobs$id[i],
        '.unmapped.score.gz'
      ))
  
  names(score_i)[names(score_i) == 'SCORE_external'] <- 'BETA'
  score_i <- score_i[, c('SNP','A1','A2','BETA'), with=F]
  n_orig <- sum(score_i$BETA != 0)
  
  # Restrict to variants in rsq browser to avoid this reference increasing missingness
  score_i <- score_i[score_i$SNP %in% rsq_subset$SNP,]
  n_rsqbrows <- sum(score_i$BETA != 0)

  # Calculate relative PRS R2 across arrays and panels
  rsq_subset_j <- rsq_subset[, c('SNP', jobs$test[i]), with = F]
  rsq_subset_j$F_MISS <- 1 - rsq_subset_j[[jobs$test[i]]]

  rel_r2 <- rel_pgs_r2_missing_eigen(
    ld_dir = '~/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/sbayesrc_ref_dense/EUR',
    score_df = score_i,
    f_miss = rsq_subset_j, 
    metric = 'correlation')
  
  res <- data.table(
    ID = jobs$id[i],
    group = jobs$test[i],
    n_nz = n_orig,
    n_in_rsqbrowser = n_rsqbrows,
    n_in_eig = rel_r2$n_in_ref,
    rel_r2 = rel_r2$relative_R2
  )
  
  write.table(
    res, 
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.', 
      jobs$test[i],
      '.rsq.txt'
    ), col.names = T, row.names = F, quote = F)
  
  NULL
}

```

```{r}
library(data.table)
library(tidyr)
library(dplyr)
library(ggplot2)
library(cowplot)

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

jobs <-
  CJ(
    id = score_list$name,
    test = c(
      "HC_1kg",
      "HC_hrc",
      "HC_top",
      "OE_1kg",
      "OE_hrc",
      "OE_top",
      "IO_1kg",
      "IO_hrc",
      "IO_top",
      "MG_1kg",
      "MG_hrc",
      "MG_top"
    ),
    unique = TRUE
  )

pgs_r2 <- NULL
for(i in 1:nrow(jobs)){
  pgs_r2 <- rbind(
    pgs_r2,
    fread(
      paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.', 
      jobs$test[i],
      '.rsq.txt'
      )
    )
  )
}

pgs_r2$array <- gsub('_.*','', pgs_r2$group)
pgs_r2$panel <- gsub('.*_','', pgs_r2$group)

# Recode panels
pgs_r2$panel <- factor(
  pgs_r2$panel,
  levels = c("1kg", "hrc", "top"),
  labels = c("1000 Genomes", "HRC", "TOPMed")
)

# Recode arrays
pgs_r2$array <- factor(
  pgs_r2$array,
  levels = c("HC", "OE", "MG", "IO"),
  labels = c("Core", "OmniExpress", "MEGA", "Omni 2.5M")
)

saveRDS(pgs_r2, '~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen.rds')
pgs_r2<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen.rds')

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen.png',
    units = 'px',
    width = 2500,
    height = 1500,
    res = 300)

ggplot(pgs_r2[pgs_r2$ID %in% unique(pgs_r2$ID)[1:5],], aes(x = array, y = rel_r2, fill = ID)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  facet_grid(. ~ panel) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Genotyping array", y = "Proportion", fill = "SNP list",
       title = "Relative PGS performance by platform and array") +
  theme_half_open() +
  panel_border() +
  background_grid() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) 
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_eigen.png',
    units = 'px',
    width = 2500,
    height = 1500,
    res = 300)

ggplot(pgs_r2, aes(x = array, y = rel_r2, fill = panel)) +
  geom_boxplot() +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Array", y = "Relative R2", title = "Distribution by metric, array, and panel") +
  theme_half_open() +
  background_grid()
dev.off()

# Plot number of variants not in eigen reference
pgs_r2$n_miss <- pgs_r2$n_nz - pgs_r2$n_in_eig
pgs_r2$prop_miss <- pgs_r2$n_miss / pgs_r2$n_nz

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/prop_miss_eigen_hist.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  pgs_r2[pgs_r2$group == 'HC_1kg',], 
  aes(x = prop_miss)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_histogram(bins = 60, width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'Missing from LD reference', y = 'N PGS') +
  theme_half_open() +
  background_grid()
dev.off()

# Calculate medians
median_table <- pgs_r2 %>%
  group_by(panel, array) %>%
  summarise(median_prop_miss = median(prop_miss, na.rm = TRUE),
            median_rel_r2 = median(rel_r2, na.rm = TRUE),
            .groups = "drop") %>%
  arrange(panel, array)

# Plot number of variants not in eigen reference
pgs_r2$n_miss <- pgs_r2$n_nz - pgs_r2$n_in_eig
pgs_r2$prop_miss <- pgs_r2$n_miss / pgs_r2$n_nz

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rel_r2_omni_topmed_hist.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  pgs_r2[pgs_r2$group == 'IO_top',], 
  aes(x = rel_r2)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_histogram(bins = 60, width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'Relative PGS R2', y = 'N PGS') +
  theme_half_open() +
  background_grid()
dev.off()

```

The main limitation of this analysis is that it only considers SNPs in the SBayesRC matrix, well imputed common variants.

***

# Evaluate method for estimating relative PGS R2 given missingness and imperfect imputation

***

## Light simulation

```{r}
# --- Setup ---------------------------------------------------------------
library(data.table)
library(Matrix)

# ----- helpers -----
make_ld <- function(m=1000, rho=0.9) {
  d <- abs(outer(1:m, 1:m, "-"))
  rho^d
}

# symmetric sqrt of R
Rsqrt <- function(U, lambda) U %*% diag(sqrt(lambda)) %*% t(U)

# minimal map_score for allele direction
map_score <- function(ref, score){
  m <- merge(ref[, .(SNP, A1_ref=A1, A2_ref=A2)], score, by="SNP", sort=FALSE, all.y=TRUE)
  flip <- m$A1_ref==m$A2 & m$A2_ref==m$A1
  m$BETA[isTRUE(flip)] <- -m$BETA[isTRUE(flip)]
  m[, c("A1","A2") := .(A1_ref, A2_ref)]
  m[, c("A1_ref","A2_ref") := NULL]
  m
}

# your IO + estimator (unchanged)
readEig <- function(ldDir, block){
  ldfile = file.path(ldDir, paste0("block", block, ".eigen.bin"))
  hLD = file(ldfile, "rb"); on.exit(close(hLD))
  m  = readBin(hLD, integer(), n=1, size=4)
  k  = readBin(hLD, integer(), n=1, size=4)
  sumLambda = readBin(hLD, numeric(), n=1, size=4)
  thresh    = readBin(hLD, numeric(), n=1, size=4)
  lambda = readBin(hLD, numeric(), n=k, size=4)
  mat    = readBin(hLD, numeric(), n=m*k, size=4); dim(mat) = c(m,k)
  list(m=m, k=k, sumLambda=sumLambda, thresh=thresh, lambda=lambda, U=mat)
}
rel_pgs_r2_missing_eigen_fixed <-
  function(ld_dir,
           score_df,
           f_miss,
           metric = c("correlation", "variance")) {
    
  metric <- match.arg(metric)
    
  snp_info <- data.table::fread(file.path(ld_dir, "snp.info"))
  data.table::setnames(snp_info, "ID", "SNP")
  snp_info[, S := sqrt(2 * A1Freq * (1 - A1Freq))]
  snp_info[, idx := .I]

  # Keep only needed cols, map alleles/flip betas if needed
  score_df <- score_df[, .(SNP, A1, A2, BETA)]
  score_df <- map_score(ref = snp_info, score = score_df)  # your mapper handles flips

  # --- REORDER to snp.info order (critical) ---
  ord <- match(snp_info$SNP, score_df$SNP)
  score_df <- score_df[ord]

  # Merge F_MISS in the same order
  score_df <- f_miss[score_df, on = "SNP"]
  score_df[is.na(F_MISS), F_MISS := 1]
  score_df[, call_rate := pmax(0, pmin(1, 1 - F_MISS))]

  den_sum <- 0.0                # w' R w
  sig_sum <- 0.0                # w' M R M w
  cov_sum <- 0.0                # w' M R w
  noise_sum <- 0.0              # sum_j (1 - c_j) w_j^2  nz <- which(score_df$BETA != 0)
  
  nz <- which(score_df$BETA != 0)

  if (!length(nz)) return(list(relative_R2 = NA_real_, n_in_ref = 0L))
  nz_blocks <- unique(snp_info$Block[nz])

  for (b in nz_blocks) {
    idx_b <- which(snp_info$Block == b)
    if (!length(idx_b) || !any(score_df$BETA[idx_b] != 0)) next

    eig <- readEig(ldDir = ld_dir, block = b)

    w_b      <- snp_info$S[idx_b] * score_df$BETA[idx_b]
    callb <- score_df$call[idx_b]

    Ut_w  <- as.numeric(crossprod(eig$U, w_b))
    Ut_wm  <- as.numeric(crossprod(eig$U, sqrt(callb) * w_b))

    den_sum   <- den_sum   + sum(eig$lambda * Ut_w^2)
    sig_sum   <- sig_sum   + sum(eig$lambda * Ut_wm^2)
    cov_sum   <- cov_sum   + sum(eig$lambda * Ut_w * Ut_wm)
    noise_sum <- noise_sum + sum((1 - callb) * (w_b^2))
  }

  if (metric == "variance") {
    rel <- if (den_sum > 0) sig_sum / den_sum else NA_real_
  } else { # correlation-consistent
    denom_imp <- sig_sum + noise_sum
    rel <- if (den_sum > 0 && denom_imp > 0) (cov_sum^2) / (den_sum * denom_imp) else NA_real_
  }
  
  list(relative_R2 = rel,
       parts = list(den = den_sum, sig = sig_sum, cov = cov_sum, noise = noise_sum),
       n_in_ref    = sum(score_df$BETA != 0 & score_df$SNP %in% snp_info$SNP))
}

# write eigen file matching readEig format
write_eig_bin <- function(U, lambda, path){
  con <- file(path,"wb"); on.exit(close(con))
  writeBin(as.integer(nrow(U)), con, size=4)
  writeBin(as.integer(ncol(U)), con, size=4)
  writeBin(as.numeric(sum(lambda)), con, size=4)
  writeBin(as.numeric(0),          con, size=4)
  writeBin(as.numeric(lambda),     con, size=4)
  writeBin(as.numeric(U),          con, size=4)
}

# ----- simulation (corrected) -----
simulate_once <- function(m=1200, N=40000, rho=0.95,
                          maf_min=0.05, maf_max=0.5, h2=0.10,
                          rsq_vec=NULL, drop_frac=0.0) {
  set.seed(NULL)

  # LD and eigen
  R   <- make_ld(m, rho)
  eR  <- eigen(R, symmetric=TRUE)
  U   <- eR$vectors; lambda <- pmax(eR$values, 1e-9)

  # genotypes ~ MVN(0,R)
  Z   <- matrix(rnorm(N*m), N, m)
  L   <- t(chol(R))                   # t(chol) so Z%*%L has Cov ≈ R
  Gs  <- Z %*% L                      # N x m, mean~0, Cov~R

  # allele frequencies and scaling to per-SNP SD
  p    <- runif(m, maf_min, maf_max)
  S    <- sqrt(2*p*(1-p))
  G    <- sweep(Gs, 2, S, `*`)        # scale columns to allele SD

  # effects scaled to target h2
  beta_raw <- rnorm(m)
  w <- S * beta_raw
  v <- sum((sqrt(lambda) * as.numeric(crossprod(U, w)))^2)  # w' R w
  scale <- sqrt(h2 / v)
  beta <- beta_raw * scale
  
  if (is.null(rsq_vec)) rsq_vec <- rep(0.9, m)
  if (drop_frac > 0) {
    drop <- sample.int(m, size = floor(drop_frac*m))
    rsq_vec[drop] <- 0
  }
  call <- pmin(pmax(rsq_vec, 0), 1)
  
  # phenotype with Var(y)=1
  pg_full <- as.numeric(G %*% beta)
  s2 <- var(pg_full)
  y  <- pg_full + rnorm(N, sd=sqrt(1 - s2))

  # construct imputed G*: preserve per-SNP variance, reduce cross-covariances
  E  <- matrix(rnorm(N*m), N, m)
  sdG <- apply(G, 2, sd)
  Gimp <- sweep(G, 2, sqrt(pmax(rsq_vec,0)), `*`) +
          sweep(E, 2, sqrt(pmax(1 - rsq_vec,0)) * sdG, `*`)

  pg_imp <- as.numeric(Gimp %*% beta)

  r2_full <- cor(pg_full, y)^2
  r2_imp  <- cor(pg_imp,  y)^2
  rel_emp <- r2_imp / r2_full

  # files for estimator
  ld_dir <- tempfile("ld"); dir.create(ld_dir)
  snp_info <- data.table(
    ID=paste0("rs", seq_len(m)),
    A1=sample(c("A","C","G","T"), m, TRUE),
    A2=sample(c("A","C","G","T"), m, TRUE),
    A1Freq=p, Block=1L
  )
  fwrite(snp_info, file.path(ld_dir, "snp.info"), sep="\t")
  write_eig_bin(U, lambda, file.path(ld_dir, "block1.eigen.bin"))
  score_df <- data.table(SNP=snp_info$ID, A1=snp_info$A1, A2=snp_info$A2, BETA=beta)
  f_miss   <- data.table(SNP=snp_info$ID, F_MISS=1 - pmin(rsq_vec, 1))

  est <- rel_pgs_r2_missing_eigen_fixed(ld_dir, score_df, f_miss)
  list(rel_emp=rel_emp, rel_pred=est$relative_R2,
       r2_full=r2_full, r2_imp=r2_imp)
}

# ----- examples -----
set.seed(42)
# Constant Rsq
out1 <- simulate_once(rsq_vec=rep(0.9, 1200))
out2 <- simulate_once(rsq_vec=rep(0.8, 1200))
# MAF-dependent Rsq (worse at low MAF)
m <- 1200; p <- runif(m, 0.05, 0.5)
rsq_maf <- pmin(0.99, 0.5 + (p - 0.05)/0.45 * 0.49)
out3 <- simulate_once(rsq_vec=rsq_maf)
# Mixed + 10% dropped
rsq_mix <- pmin(0.99, 0.7 + rbeta(m, 5, 2)*0.3)
out4 <- simulate_once(rsq_vec=rsq_mix, drop_frac=0.10)

rbindlist(list(
  data.table(name="Const 0.9", data.frame(out1)),
  data.table(name="Const 0.8", data.frame(out2)),
  data.table(name="By MAF",    data.frame(out3)),
  data.table(name="Mixed +10%",data.frame(out4))
))

#          name   rel_emp  rel_pred    r2_full     r2_imp
#        <char>     <num>     <num>      <num>      <num>
# 1:  Const 0.9 0.9437642 0.9283186 0.09407768 0.08878715
# 2:  Const 0.8 0.7604157 0.7617772 0.10030610 0.07627433
# 3:     By MAF 0.7538703 0.7475635 0.10151816 0.07653153
# 4: Mixed +10% 0.7746066 0.7615950 0.10294365 0.07974083
# There is good agreement.
```

***

## Semi-empirical

Compare predicted and observed relative drop in PGS R2 using real CAD PGS and simulated phenotype in 1KG EUR subset, introducing missingness and imputation quality matching that observed in RsqBrowser.

***

```{r}
# Subset the 1KG+HGDP reference to EUR individuals with variants in SBayesRC reference and RsqBrowser
dir.create('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target', recursive = T)

merge_list <- paste0('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/ref_dense_incl_ambig/ref.chr', 1:22)
write.table(merge_list, '~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/merge_list.txt', col.names = F, row.names = F, quote = F)

sbayesrc_snpinfo <- fread('~/oliverpainfel/Data/SBayesRC/ukbEUR_Imputed/snp.info') # Build GRCh37
ref<-NULL
for(i in 1:22){
  ref <- rbind(ref, readRDS(paste0('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/ref_dense_incl_ambig/ref.chr', i,'.rds')))
}

ref_subset <- merge(
  ref[, c('CHR', 'SNP', 'BP_GRCh37', 'A1', 'A2'), with = F], 
  sbayesrc_snpinfo[, c('Chrom', 'PhysPos', 'A1', 'A2')],
  by.x = c('CHR','BP_GRCh37'), by.y = c('Chrom', 'PhysPos'))

ref_subset <- ref_subset[ (A1.x == A1.y & A2.x == A2.y) |
                          (A1.x == A2.y & A2.x == A1.y),]

rsqtab  <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')
ref_subset <- ref_subset[ref_subset$SNP %in% rsqtab$SNP,]

write.table(ref_subset$SNP, '~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/extract.txt', col.names = F, row.names = F, quote = F)
```

```{bash}
# Merge chromosome 1-22
# Subset to SBayesRC reference variants
# Subset to EURmodule add plink2
plink2 \
  --pmerge-list ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/merge_list.txt \
  --extract ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/extract.txt \
  --keep /users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/ref_dense_incl_ambig/keep_files/EUR.keep \
  --freq \
  --make-pgen \
  --out ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target

```

```{bash}
# Calculate PGS in target using CAD PGS files
mkdir -p ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline

for id in $(tail -n+2 ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt | cut -f 1 -d ' '); do
  sbatch --mem 2G -n 1 -p neurohack_cpu -t 1:00:00 --wrap="
  zcat ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/${id}/ref-${id}.score.gz \
    | awk 'NR==1 || \$4 != 0' \
    | gzip > ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/${id}/ref-${id}.score.nonzero.gz"
done

for id in $(tail -n+2 ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt | cut -f 1 -d ' '); do
  sbatch --mem 2G -n 1 -p neurohack_cpu -t 1:00:00 --wrap="
  plink2 \
    --pfile ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target \
    --score ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/${id}/ref-${id}.score.nonzero.gz 1 2 4 header cols=+scoresums variance-standardize \
    --out ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline/${id}"
done

```

```{r}
# Read in PGS
score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

for(i in score_list$name){
  if(!file.exists(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline/', i,'.sscore'))){
    next
  }
  pgs <- fread(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline/', i,'.sscore'))
  pgs <- pgs[,c('#IID', 'SCORE1_SUM'), with=F]
  names(pgs)<-c('ID',i)
  
  if(i == score_list$name[1]){
    pgs_all <- pgs
  } else {
    pgs_all <- data.table(pgs_all, pgs[,i, with=F])
  }
}

# Z: N x 70 matrix of standardized full PGSs (one column per score)
Z <- scale(pgs_all[,-1, with=F])
pc <- prcomp(Z, center=FALSE, scale.=FALSE)

plot(pc$rotation[,1], pc$rotation[,2]) # There are three PGS that load negatively on PC1, possibly indicating A1/A2 swap

pc$rotation[,1][pc$rotation[,1] < -0.1] # PGS000116  PGS004237  PGS004888 
which.max(pc$rotation[,1]) # PGS000013

g  <- pc$x[,1] / sd(pc$x[,1])            # PC1, unit variance

h2 <- 0.50
set.seed(1)
y  <- sqrt(h2) * g + rnorm(length(g), sd = sqrt(1 - h2))

write.table(
  data.table(ID = pgs_all$ID, y = y),
  '~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pheno.txt',
  col.names = T, row.names = F, quote = F)

# Calculate variance explained by PGS (this will be the baseline)
r2_full <- data.table(ID = names(pgs_all)[-1], R2 = cor(pgs_all[,-1, with=F], y)[,1]^2)

write.table(
  r2_full,
  '~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/baseline_r2.txt',
  col.names = T, row.names = F, quote = F)

# Look into negatively loading PGS
PGS000116 <- fread('~/PGS000116_hmPOS_GRCh37.txt.gz')
PGS000013 <- fread('~/PGS000013_hmPOS_GRCh37.txt.gz')

top <- head(PGS000116[order(-abs(PGS000116$effect_weight)), c('hm_chr','hm_pos','hm_rsID'), with=F])
PGS000116_top <- merge(PGS000116, top, by=c('hm_chr','hm_pos'))
PGS000013_top <- merge(PGS000013, top, by=c('hm_chr','hm_pos'))

# For example, the G allele is well documented as the risk allele for rs4977574.
# The Khera PGS (PGS000013) is conguent with this, but the PGS000116 is not
PGS000116_top[hm_rsID.y == 'rs4977574', c('hm_rsID.y', 'effect_allele','other_allele','effect_weight'), with=F]
#   hm_rsID.y effect_allele other_allele effect_weight
#1: rs4977574             A            G    0.01741151
   
PGS000013_top[hm_rsID.y == 'rs4977574', c('hm_rsID.y', 'effect_allele','other_allele','effect_weight'), with=F]
#   hm_rsID.y effect_allele other_allele effect_weight
#1: rs4977574             G            A      0.014236

# This highlights a gotcha of the PGS catalogue. Same goes for GWAS catalogue probably.
# Using correlation between PGS is a good sanity check.

```

```{r}
# Create score files with attenuated weights
# This will simulate noise from imputation
dir.create('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/atten_weights')

library(data.table)
freq    <- fread("~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target.afreq")
freq <- freq[, c('ID','REF','ALT','ALT_FREQS'), with = F]
names(freq)<-c('SNP','A2','A1','FREQ')
rsqtab  <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')
rsqtab_subset <- rsqtab[, c('SNP','HC_1kg'), with = F]
names(rsqtab_subset) <- c('SNP','call')
rsqtab_subset <- rsqtab_subset[rsqtab_subset$SNP %in% freq$SNP,]

for(i in score_list$name){
  print(i)
  if(!file.exists(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline/', i,'.sscore'))){
    next
  }

  score <-
    fread(
      paste0(
        '~/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        i,
        '/ref-',
        i,
        '.score.nonzero.gz'
      ))
      
  setnames(score, "SCORE_external", "BETA")
  
  dt <- merge(score, freq[, .(SNP, FREQ)], by="SNP")
  dt <- merge(dt, rsqtab_subset[, .(SNP, call=pmin(pmax(call,0),1))], by="SNP", all.x=TRUE)
  dt[is.na(call), call := 0]
  
  # allele SD and “true” weights w_j = S_j * BETA_j (used for noise variance)
  dt[, S := sqrt(2 * pmin(FREQ, 1-FREQ) * (1 - pmin(FREQ, 1-FREQ)))]
  dt[, w_true := S * BETA]
  
  # attenuated weights for the signal term
  dt[, BETA_att := sqrt(call) * BETA]
  fwrite(dt[, .(SNP, A1, BETA_att)], paste0("~/oliverpainfel/Analyses/mind_the_gap/sim/emp/atten_weights/HC_1kg.", i,".txt"), sep="\t", quote=F)
  
  # Save noise variance for the per-individual draw
  sigma2_noise <- dt[, sum((1 - call) * w_true^2, na.rm = TRUE)]
  write.table(
    sigma2_noise,
    paste0(
      "~/oliverpainfel/Analyses/mind_the_gap/sim/emp/atten_weights/HC_1kg.",
      i,
      ".sigma_noise.txt"
    ),
    col.names = F,
    row.names = F,
    quote = F
  )
}

```

```{bash}
# Calculate attenuated PGS in target
mkdir -p ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/attenuated/HC_1kg

for id in $(tail -n+2 ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt | cut -f 1 -d ' '); do
  sbatch --mem 2G -n 1 -p neurohack_cpu -t 1:00:00 --wrap="
  plink2 \
    --pfile ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target \
    --score ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/atten_weights/HC_1kg.${id}.txt 1 2 3 header cols=+scoresums variance-standardize \
    --out ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/attenuated/HC_1kg/${id}"
done

```

```{r}
# Calculate correlation betwee attenuated PGS and phenotype
# Read in PGS
score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

for(i in score_list$name){
  if(!file.exists(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/attenuated/HC_1kg/', i,'.sscore'))){
    next
  }
  pgs <- fread(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/attenuated/HC_1kg/', i,'.sscore'))
  pgs <- pgs[,c('#IID', 'SCORE1_SUM'), with=F]
  
  sigma2_noise <- read.table(paste0(
      "~/oliverpainfel/Analyses/mind_the_gap/sim/emp/atten_weights/HC_1kg.",
      i,
      ".sigma_noise.txt"
    ), header = F)$V1
  
  pgs$SCORE1_SUM <- pgs$SCORE1_SUM + rnorm(nrow(pgs), sd = sqrt(sigma2_noise))

  names(pgs)<-c('ID',i)
  
  if(i == score_list$name[1]){
    pgs_all <- pgs
  } else {
    pgs_all <- data.table(pgs_all, pgs[,i, with=F])
  }
}

# read in pheno
pheno <- fread('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pheno.txt')

# Calculate variance explained by PGS (this will be the baseline)
r2_atten <- data.table(ID = names(pgs_all)[-1], R2_atten = cor(pgs_all[,-1, with=F], pheno$y)[,1]^2)

# Compare to baseline
r2_full <- fread('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/baseline_r2.txt')
names(r2_full) <- c('ID','R2_full')

results <- merge(r2_atten, r2_full, by = 'ID')
results$rel_r2 <- results$R2_atten / results$R2_full

write.table(
  results,
  '~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/relative_r2.txt',
  col.names = T, row.names = F, quote = F)

```

***

### Compare estimated and semi-empirical 'observed' relative R2

```{r}
# Compare estimated and observed relative R2
obs_rel_r2 <- fread('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/relative_r2.txt')
setnames(obs_rel_r2, 'rel_r2', 'obs_rel_r2')

est_rel_r2 <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen.rds')
est_rel_r2 <- est_rel_r2[est_rel_r2$group == 'HC_1kg',]
setnames(est_rel_r2, 'rel_r2', 'est_rel_r2')

both <- merge(obs_rel_r2, est_rel_r2, by = 'ID')

plot(both$est_rel_r2, both$obs_rel_r2)
cor(both$est_rel_r2, both$obs_rel_r2) # -0.4261504

# I appears the deviation from 1 is consistent with the estimated relative r2
both$obs_rel_r2_abs <- both$obs_rel_r2
both$obs_rel_r2_abs[both$obs_rel_r2 > 1] <- 1 - (both$obs_rel_r2[both$obs_rel_r2 > 1] - 1)

plot(both$est_rel_r2, both$obs_rel_r2_abs)
cor(both$est_rel_r2, both$obs_rel_r2_abs) # 0.7255726

# This doesn't work. It doesn't account for LD, and makes similar assumptions to the estimator. We need an assumption free validation approach.
```

***

## Empirical simulation

It is hard to simulate data with noisy genotypes due to imputation, and the previous approach of estimating noise is challening and also has overlapping assumptions with estimator. Instead, lets remove variants with INFO below certain thresholds, and see whether the observed decrease in R2 can be predicted using our estimator. To make this computationally efficient, remove variants with INFO below certain threshold from the score file.

```{r}
# List variants with RSQ > x
dir.create('~/oliverpainfel/Analyses/mind_the_gap/sim/masking')

library(data.table)
freq    <- fread("~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target.afreq")
freq <- freq[, c('ID','REF','ALT','ALT_FREQS'), with = F]
names(freq)<-c('SNP','A2','A1','FREQ')
rsqtab  <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_browser.rds')
rsqtab_subset <- rsqtab[, c('SNP','HC_1kg'), with = F]
names(rsqtab_subset) <- c('SNP','call')
rsqtab_subset <- rsqtab_subset[rsqtab_subset$SNP %in% freq$SNP,]

info_thresh <- c(0.5, 0.6, 0.7, 0.8)
for(i in info_thresh){
  fwrite(rsqtab_subset[call > i, 'SNP', with = F], paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/rsq_p',i,'.list'), col.names=F, quote = F)
}

```

```{bash}
mkdir -p ~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/pgs/masked

for rsq in $(echo 0.5 0.6 0.7 0.8); do
for id in $(tail -n+2 ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt | cut -f 1 -d ' '); do
  sbatch --mem 2G -n 1 -p neurohack_cpu -t 1:00:00 --wrap="
  plink2 \
    --pfile ~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target \
    --score ~/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/${id}/ref-${id}.score.nonzero.gz 1 2 4 header cols=+scoresums variance-standardize \
    --extract ~/oliverpainfel/Analyses/mind_the_gap/sim/masking/rsq_p${rsq}.list \
    --out ~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/pgs/masked/${id}.rsq_p${rsq}"
done
done

```

```{r}
# Now estimate the relative R2 of PGS after masking variants
setwd('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/')
library(data.table)
library(ggplot2)
library(cowplot)
library(GenoUtils)
library(foreach)
library(doMC)
registerDoMC(20)

source('../functions/misc.R')
source_all('../functions')

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

info_thresh <- c(0.6)

# Combine all the score files
ref <- fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        score_list$name[1],
        '/ref-',
        score_list$name[1],
        '.score.gz'
      ), nrows = 1000)[, c('SNP','A1','A2'), with=F]

betas <- foreach(i = 1:10, .combine = cbind, .options.multicore = list(preschedule = FALSE)) %dopar% {
  fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        score_list$name[i],
        '/ref-',
        score_list$name[i],
        '.score.gz'
      ), nThread= 1, nrows = 1000) [,-1:-3, with = F]
}

colnames(betas)<-score_list$name[1:10]
score_file<-data.table(ref, betas)

# Restrict score file to rows with non-zero betas
score_file <- score_file[apply(betas, 1, function(x) !all(x == 0)),]

# Restrict score files to variants present in target sample for comparability
freq    <- fread("~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target.afreq")
freq <- freq[, c('ID','REF','ALT','ALT_FREQS'), with = F]
names(freq)<-c('SNP','A2','A1','FREQ')

score_file <- score_file[score_file$SNP %in% freq$SNP,]

# Create call rate data.frame
snplist <- fread(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/rsq_p0.6.list'), header=F)$V1
call_rate <- data.table(
  SNP = score_file$SNP
)
call_rate$F_MISS <- 1
call_rate$F_MISS[call_rate$SNP %in% snplist] <- 0

# Calculate relative R2
rel_r2 <- rel_pgs_r2_missing_eigen_multi_par(
  ld_dir = '~/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/sbayesrc_ref_dense/EUR',
  score_df = score_file,
  f_miss = call_rate, 
  metric = 'correlation')
  
  res <- data.table(
    ID = jobs$id[i],
    group = jobs$test[i],
    n_nz = n_orig,
    n_in_targ = n_in_targ,
    n_unmasked = sum(call_rate$SNP %in% snplist),
    n_in_eig = rel_r2$n_in_ref,
    rel_r2 = rel_r2$relative_R2
  )
  
  write.table(
    res, 
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.mask_', 
      jobs$test[i],
      '.rsq.txt'
    ), col.names = T, row.names = F, quote = F)
  
  NULL
}

```

```{r}
library(data.table)
library(tidyr)
library(dplyr)
library(ggplot2)
library(cowplot)

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')
info_thresh <- c(0.5, 0.6, 0.7, 0.8)

jobs <-
  CJ(
    id = score_list$name,
    test = info_thresh,
    unique = TRUE
  )

pgs_r2 <- NULL
for(i in 1:nrow(jobs)){
  tmp <- fread(
      paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.mask_', 
      jobs$test[i],
      '.rsq.txt'
      )
    )
  if(!any('n_unmasked' %in% names(tmp))){
      tmp$n_unmasked <- NA
  }
  pgs_r2 <- rbind(
    pgs_r2,
    tmp
  )
}

saveRDS(pgs_r2, '~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/pgs/masked/rsq_metrics_pgs_eigen.rds')

```

***

### Compare estimated and masking 'observed' relative R2

```{r}
# Test variance explained between baseline and masked PGS
# Read in PGS
info_thresh <- c(0.5, 0.6, 0.7, 0.8)
score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

results <- NULL
for(rsq in info_thresh){
  for(i in score_list$name){
    if(!file.exists(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline/', i,'.sscore'))){
      next
    }
    
    baseline_pgs <- fread(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/pgs/baseline/', i,'.sscore'))
    baseline_pgs <- baseline_pgs[,c('#IID', 'SCORE1_SUM'), with=F]

    masked_pgs <- fread(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/pgs/masked/',i,'.rsq_p', rsq, '.sscore'))
    masked_pgs <- masked_pgs[,c('#IID', 'SCORE1_SUM'), with=F]

    results <- rbind(
      results,
      data.frame(
        ID = i,
        rsq = rsq,
        rel_r2 = cor(baseline_pgs$SCORE1_SUM, masked_pgs$SCORE1_SUM)^2
      )
    )
  }
}

write.table(
  results,
  '~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/relative_r2_no_pheno.txt',
  col.names = T, row.names = F, quote = F)

```

```{r}
# Compare estimated and observed relative R2
obs_rel_r2 <- fread('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/relative_r2_no_pheno.txt')
setnames(obs_rel_r2, 'rel_r2', 'obs_rel_r2')

est_rel_r2 <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/pgs/masked/rsq_metrics_pgs_eigen.rds')
setnames(est_rel_r2, 'rel_r2', 'est_rel_r2')
setnames(est_rel_r2, 'group', 'rsq')

both <- merge(obs_rel_r2, est_rel_r2, by = c('ID','rsq'))
both$rsq <- paste0('Masked RSQ < ', both$rsq)

library(dplyr)

N <- nrow(both)

metrics <- both %>%
  group_by(rsq) %>%
  summarise(
    pearson_r = cor(est_rel_r2, obs_rel_r2, use="complete.obs"),
    spearman_rho = cor(est_rel_r2, obs_rel_r2, method="spearman", use="complete.obs"),
    # Fisher z CI for Pearson r
    z = atanh(pearson_r),
    se_z = 1 / sqrt(N - 3),
    r_low = tanh(z - 1.96 * se_z),
    r_high = tanh(z + 1.96 * se_z),
    # Regression slope + CI
    slope = coef(lm(obs_rel_r2 ~ est_rel_r2))[2],
    slope_ci_low = confint(lm(obs_rel_r2 ~ est_rel_r2))[2,1],
    slope_ci_high = confint(lm(obs_rel_r2 ~ est_rel_r2))[2,2],
    .groups = "drop"
  )

# Annotate with CI text
metrics$text <- paste0("r = ", round(metrics$pearson_r, 2),
                       " [", round(metrics$r_low, 2), ", ", round(metrics$r_high, 2), "]",
                       "\nβ = ", round(metrics$slope, 2),
                       " [", round(metrics$slope_ci_low, 2), ", ", round(metrics$slope_ci_high, 2), "]")

png('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/target/pgs/masked/obs_est_validation.png',
    units = 'px',
    width = 2500,
    height = 2500,
    res = 300)

ggplot(both, aes(x = both$est_rel_r2, y = both$obs_rel_r2)) +
  geom_abline(colour = 'red') +
  geom_point() +
  facet_wrap(. ~ rsq) +
  coord_fixed() +
  theme_half_open() +
  panel_border() +
  background_grid() +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0,1)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0,1)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(x = 'Estimated relative R2', y = 'Observed relative R2') +
  geom_text(data = metrics, aes(x = 0.3, y = 0.95, label = text), inherit.aes = FALSE, size = 4)

dev.off()

# Good this confirms the approach is valid.
```

***

# Test multi-PGS R2 estimation function

```{r}
# Now estimate the relative R2 of PGS after masking variants
setwd('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/')
library(data.table)
library(ggplot2)
library(cowplot)
library(GenoUtils)
library(foreach)
library(doMC)
registerDoMC(10)

source('../functions/misc.R')
source_all('../functions')

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')
info_thresh <- c(0.5, 0.6, 0.7, 0.8)

# Restrict score files to variants present in target sample for comparability
freq    <- fread("~/oliverpainfel/Analyses/mind_the_gap/sim/emp/target/target.afreq")
freq <- freq[, c('ID','REF','ALT','ALT_FREQS'), with = F]
names(freq)<-c('SNP','A2','A1','FREQ')

jobs <-
  CJ(
    id = score_list$name,
    test = info_thresh,
    unique = TRUE
  )

foreach(i = 1:nrow(jobs), .combine = c, .options.multicore = list(preschedule = FALSE)) %dopar% {
  if(file.exists(
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.mask_', 
      jobs$test[i],
      '.rsq.txt'
    ))){
    return(NULL)
  }
  
  print(paste0(jobs$id[i],':', jobs$test[i]))
  
  snplist <- fread(paste0('~/oliverpainfel/Analyses/mind_the_gap/sim/masking/rsq_p',jobs$test[i],'.list'), header=F)$V1
  
  # Read in score file
  score_i <- fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        jobs$id[i],
        '/ref-',
        jobs$id[i],
        '.score.gz'
      ))
  
  names(score_i)[names(score_i) == 'SCORE_external'] <- 'BETA'
  score_i <- score_i[, c('SNP','A1','A2','BETA'), with=F]
  n_orig <- sum(score_i$BETA != 0)
  
  # Restrict to variants in target sample for comparability
  score_i <- score_i[score_i$SNP %in% freq$SNP,]
  score_i <- score_i[, c('SNP','A1','A2','BETA'), with=F]
  n_in_targ <- sum(score_i$BETA != 0)
  
  # Create call rate data.frame
  call_rate <- data.table(
    SNP = score_i$SNP
  )
  call_rate$F_MISS <- 1
  call_rate$F_MISS[call_rate$SNP %in% snplist] <- 0
  
  rel_r2 <- rel_pgs_r2_missing_eigen(
    ld_dir = '~/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/sbayesrc_ref_dense/EUR',
    score_df = score_i,
    f_miss = call_rate, 
    metric = 'correlation')
  
  res <- data.table(
    ID = jobs$id[i],
    group = jobs$test[i],
    n_nz = n_orig,
    n_in_targ = n_in_targ,
    n_unmasked = sum(call_rate$SNP %in% snplist),
    n_in_eig = rel_r2$n_in_ref,
    rel_r2 = rel_r2$relative_R2
  )
  
  write.table(
    res, 
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.mask_', 
      jobs$test[i],
      '.rsq.txt'
    ), col.names = T, row.names = F, quote = F)
  
  NULL
}
```

***

# Find set of well imputed variants

Using data from the rsq browser, find a subset of variants with high imputation quality across arrays, imputation panels, and ancestries. Drop the HC chip as not representative, and also drop the 1KG panel as most datasets are HRC or topmed imputed these days.

```{r}
library(data.table)

populations <- c('EUR','AMR','AFR','FIN')
n <- c(2429, 3141, 7169, 2703)
files <-
  c(
    'mlof.bi.snv.tab.gz',
    'biome.bi.snv.tab.gz',
    'inpsyght.bi.snv.tab.gz',
    'metsim.bi.snv.tab.gz'
  )

for(i in 1:length(populations)){
  rsq <- fread(paste0('~/oliverpainfel/Data/RsqBrowser2/', files[i]))
  rsq$MAF <- rsq$AF
  rsq$MAF[rsq$AF > 0.5] <- 1 - rsq$AF[rsq$AF > 0.5]
  rsq$MAC <- 2*n[i]*rsq$MAF
  
  # Remove rows with MAC < 20 to avoid inaccurate rsq
  rsq <- rsq[rsq$MAC > 20,]
  
  # Subset rsq columns for relevant arrays and panels
  rsq_metrics <-
    rsq[, grepl('^OE|^IO|^MG', names(rsq)) &
          grepl('hrc$|top$', names(rsq)) &
          !grepl('_in$', names(rsq)), with = F]
  
  # Set NA to 0
  rsq_metrics[is.na(rsq_metrics)] <- 0
  
  # Identify to rsq > 0.95
  rsq_95 <- apply(rsq_metrics, 1, function(x) min(x) > 0.95)
  
  # Identify MAF > 0.001 - Relaxed threshold, but removes dodgy rsq estimates.
  fwrite(
    rsq[rsq_95, c('CHR', 'POS', 'REF', 'ALT', 'AF'), with = F],
    paste0(
      '~/oliverpainfel/Data/RsqBrowser2/',
      populations[i],
      '.min_rsq_95.mac_20.txt.gz'
    ),
    sep = ' ',
    quote = F,
    na = 'NA'
  )
}

rsq_95_all <- list()
for(i in 1:length(populations)){
  tmp <- fread(paste0(
    '~/oliverpainfel/Data/RsqBrowser2/',
    populations[i],
    '.min_rsq_95.mac_20.txt.gz'
  ))
  tmp$ID <- paste0(tmp$CHR,':',tmp$POS,':',tmp$REF,':',tmp$ALT)
  
  rsq_95_all[[populations[i]]] <- tmp$ID
}

library(VennDiagram)

display_venn <- function(x, ...){
  library(VennDiagram)
  grid.newpage()
  venn_object <- venn.diagram(x, filename = NULL, ...)
  grid.draw(venn_object)
}

display_venn(rsq_95_all)

# There are ~3M variants that are well imputed in all populations.
# There are ~6M variants that are well imputed in EUR

library(UpSetR)
upset(fromList(rsq_95_all), order.by = "freq")

```

***

# Real world example: PGC ADR

I have downloaded the imputation info scores across PGC antidepressant response datasets that have been imputed using the HRC imputation panel. Check the info of HapMap3 and SBayesRC variants. Then calculate relative PGS R2 of CAD PGS.

***

## SNP-list availability

```{r}
library(data.table)

# Read in snplist and rsq information
hm3 <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/hm3.rds')
sbayesrc <- readRDS('~/oliverpainfel/Analyses/mind_the_gap/snp_data/sbayesrc_7m.rds')

# We will merge by SNP, A1 and A2 information, so delete other information
hm3$CHR <- NULL
hm3$BP <- NULL
sbayesrc$CHR <- NULL
sbayesrc$BP <- NULL

cohorts <- c('gsk','dast','genpod','gendep','pfz','gods','mayo')
all_rsq <- NULL
for(cohort in cohorts){
  print(cohort)
  dat <- fread(paste0('~/oliverpainfel/Data/mind_the_gap/pgc_adr/', cohort,'.info.gz'))
  dat <- dat[, c('SNP','a1','a2','info'), with=F]
  names(dat)<-c('SNP','A1','A2','INFO')

  # Merge with hm3 and sbayesrc snplists
  hm3_rsq <- merge(hm3, dat, by = 'SNP', all.x = T)
  hm3_rsq <- hm3_rsq[
    (hm3_rsq$A1.x == hm3_rsq$A1.y & hm3_rsq$A2.x == hm3_rsq$A2.y) |
    (hm3_rsq$A1.x == hm3_rsq$A2.y & hm3_rsq$A2.x == hm3_rsq$A1.y) |
    is.na(hm3_rsq$A2.y),]
  hm3_rsq<-hm3_rsq[, c('SNP','A1.x','A2.x','INFO'), with = F]
  names(hm3_rsq) <- c('SNP','A1','A2','INFO')
  hm3_rsq$INFO[is.na(hm3_rsq$INFO)] <- 0
  hm3_rsq$snplist <- 'hm3'
  
  sbayesrc_rsq <- merge(sbayesrc, dat, by = 'SNP', all.x = T)
  sbayesrc_rsq <- sbayesrc_rsq[
    (sbayesrc_rsq$A1.x == sbayesrc_rsq$A1.y & sbayesrc_rsq$A2.x == sbayesrc_rsq$A2.y) |
    (sbayesrc_rsq$A1.x == sbayesrc_rsq$A2.y & sbayesrc_rsq$A2.x == sbayesrc_rsq$A1.y) |
    is.na(sbayesrc_rsq$A2.y),]
  sbayesrc_rsq<-sbayesrc_rsq[, c('SNP','A1.x','A2.x','INFO'), with = F]
  names(sbayesrc_rsq) <- c('SNP','A1','A2','INFO')
  sbayesrc_rsq$INFO[is.na(sbayesrc_rsq$INFO)] <- 0
  sbayesrc_rsq$snplist <- 'sbayesrc'

  both_rsq <- rbind(hm3_rsq, sbayesrc_rsq)
  both_rsq$cohort <- cohort
  
  all_rsq <- rbind(all_rsq, both_rsq)
}

# Cap info to 1
all_rsq$INFO[all_rsq$INFO > 1] <- 1

# assuming both_rsq is already a data.table
summary_tab <- all_rsq[, .(
  n            = .N,
  prop_non_na  = mean(!is.na(INFO)),
  prop_gt_0.5  = mean(INFO > 0.5,  na.rm = TRUE),
  prop_gt_0.9  = mean(INFO > 0.9,  na.rm = TRUE),
  prop_gt_0.95 = mean(INFO > 0.95, na.rm = TRUE),
  prop_gt_0.99 = mean(INFO > 0.99, na.rm = TRUE),
  mean_rsq     = mean(INFO,  na.rm = TRUE),
  median_rsq   = median(INFO, na.rm = TRUE)
), by = .(snplist, cohort)]

library(ggplot2)
library(cowplot)

prop_long <- melt(
  summary_tab,
  id.vars = c("snplist","cohort"),
  measure.vars = c("prop_non_na","prop_gt_0.5","prop_gt_0.9","prop_gt_0.95","prop_gt_0.99"),
  variable.name = "metric", value.name = "prop"
)

prop_long$metric <- factor(
  prop_long$metric,
  levels = c(
    'prop_non_na',
    'prop_gt_0.5',
    'prop_gt_0.9',
    'prop_gt_0.95',
    'prop_gt_0.99'
  ),
  labels = c('Missing', 'RSQ > 0.5', 'RSQ > 0.9', 'RSQ > 0.95', 'RSQ > 0.99')
)

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_metrics_pgc.png',
    units = 'px',
    width = 2500,
    height = 2500,
    res = 300)

ggplot(prop_long, aes(x = cohort, y = prop, fill = snplist)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  facet_grid(metric ~ .) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Cohort", y = "Proportion", fill = "SNP-list") +
  theme_half_open() +
  panel_border() +
  background_grid() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
dev.off()

# Make a boxplot
boxplot<- ggplot(all_rsq, aes(x = snplist, y = INFO, fill = snplist)) +
  geom_boxplot(outliers = FALSE) +
  labs(
    x = "SNP list",
    y = expression(Imputation~r^2)) +
  theme_classic() +
  theme_half_open() +
  background_grid() +
  panel_border() +
  facet_grid(. ~ cohort, scales = "free_y") +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

png('~/oliverpainfel/Analyses/mind_the_gap/snp_data/rsq_boxplot_pgc.png',
    units = 'px',
    width = 3000,
    height = 2000,
    res = 300)

  boxplot

dev.off()


```

***

## Relative PGS R2


Same as before but this time allowing for LD when estimating relative R2.

```{r}

setwd('/users/k1806347/oliverpainfel/Software/MyGit/GenoPred/pipeline/')
library(data.table)
library(ggplot2)
library(cowplot)
library(GenoUtils)
library(foreach)
library(doMC)
registerDoMC(80)

source('../functions/misc.R')
source_all('../functions')

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

cohorts <- c('gsk','dast','genpod','gendep','pfz','gods','mayo')

# Restrict to variants in the dense SBayesRC reference
sbayesrc_info<-fread('~/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/sbayesrc_ref_dense/EUR/snp.info')

jobs <-
  CJ(
    id = score_list$name,
    test = cohorts,
    unique = TRUE
  )

foreach(i = 1:nrow(jobs), .combine = c, .options.multicore = list(preschedule = FALSE)) %dopar% {
  if(file.exists(
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.', 
      jobs$test[i],
      '.rsq.txt'
    ))){
    return(NULL)
  }
  
  print(paste0(jobs$id[i],':', jobs$test[i]))
  
  # Read in score file
  score_i <- fread(paste0(
        '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
        jobs$id[i],
        '/ref-',
        jobs$id[i],
        '.unmapped.score.gz'
      ))
  
  names(score_i)[names(score_i) == 'SCORE_external'] <- 'BETA'
  score_i <- score_i[, c('SNP','A1','A2','BETA'), with=F]
  
  # Calculate relative PRS R2
  dat <- fread(paste0('~/oliverpainfel/Data/mind_the_gap/pgc_adr/', jobs$test[i],'.info.gz'))
  dat <- dat[, c('SNP','a1','a2','info'), with=F]
  names(dat)<-c('SNP','A1','A2','INFO')
  dat$F_MISS <- 1 - dat$INFO
  dat <- dat[dat$SNP %in% sbayesrc_info$ID,]

  rel_r2 <- rel_pgs_r2_missing_eigen(
    ld_dir = '~/oliverpainfel/Software/MyGit/GenoPred/pipeline/resources/data/sbayesrc_ref_dense/EUR',
    score_df = score_i,
    f_miss = dat, 
    metric = 'correlation')
  
  res <- data.table(
    ID = jobs$id[i],
    group = jobs$test[i],
    n_nz = sum(score_i$BETA != 0),
    n_in_eig = rel_r2$n_in_ref,
    rel_r2 = rel_r2$relative_R2
  )
  
  write.table(
    res, 
    paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.', 
      jobs$test[i],
      '.rsq.txt'
    ), col.names = T, row.names = F, quote = F)
  
  NULL
}

```

```{r}
library(data.table)
library(ggplot2)
library(cowplot)
cohorts <- c('gsk','dast','genpod','gendep','pfz','gods','mayo')

score_list<-fread('~/oliverpainfel/Analyses/mind_the_gap/GenoPred/config/score_list_cad.txt')

jobs <-
  CJ(
    id = score_list$name,
    test = cohorts,
    unique = TRUE
  )

pgs_r2 <- NULL
for(i in 1:nrow(jobs)){
  pgs_r2 <- rbind(
    pgs_r2,
    fread(
      paste0(
      '/users/k1806347/oliverpainfel/Analyses/mind_the_gap/GenoPred/output/reference/pgs_score_files/external/',
      jobs$id[i],
      '/ref-',
      jobs$id[i],
      '.', 
      jobs$test[i],
      '.rsq.txt'
      )
    )
  )
}

saveRDS(pgs_r2, '~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen_pgc.rds')
pgs_r2<-readRDS('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen_pgc.rds')

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_pgs_eigen_pgc.png',
    units = 'px',
    width = 2500,
    height = 1500,
    res = 300)

ggplot(pgs_r2[pgs_r2$ID %in% unique(pgs_r2$ID)[1:5],], aes(x = group, y = rel_r2, fill = ID)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(x = "Cohort", y = "Proportion", fill = "SNP list") +
  theme_half_open() +
  panel_border() +
  background_grid() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) 
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rsq_metrics_eigen_pgc.png',
    units = 'px',
    width = 2500,
    height = 1500,
    res = 300)

ggplot(pgs_r2, aes(x = group, y = rel_r2)) +
  geom_boxplot(fill = 'steelblue') +
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Cohort", y = "Relative R2") +
  theme_half_open() +
  background_grid()
dev.off()

# Plot number of variants not in eigen reference
pgs_r2$n_miss <- pgs_r2$n_nz - pgs_r2$n_in_eig
pgs_r2$prop_miss <- pgs_r2$n_miss / pgs_r2$n_nz

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/prop_miss_eigen_hist_pgc.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  pgs_r2[pgs_r2$group == 'dast',], 
  aes(x = prop_miss)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_histogram(bins = 60, width = 0.1, fill = "steelblue", alpha = 0.6, colour = 'black') +
  labs(x = 'Missing from LD reference', y = 'N PGS') +
  theme_half_open() +
  background_grid()
dev.off()

png('~/oliverpainfel/Analyses/mind_the_gap/pgsc/rel_r2_omni_topmed_hist_pgc.png',
    units = 'px', width = 1750, height = 1000, res = 300)
ggplot(
  pgs_r2, 
  aes(x = rel_r2, fill = group)) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  geom_density(alpha = 0.6, colour = 'black') +
  labs(x = 'Relative PGS R2', y = 'N PGS') +
  theme_half_open() +
  background_grid()
dev.off()

```
